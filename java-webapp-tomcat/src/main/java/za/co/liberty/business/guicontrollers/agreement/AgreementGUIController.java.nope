package za.co.liberty.business.guicontrollers.agreement;


import java.math.BigDecimal;
import java.rmi.RemoteException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import javax.annotation.Resource;
import javax.ejb.CreateException;
import javax.ejb.EJB;
import javax.ejb.Stateless;
import javax.sql.DataSource;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.collections.MultiMap;
import org.apache.commons.collections.map.MultiValueMap;
import org.apache.commons.lang.SerializationUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;

import za.co.liberty.agreement.client.vo.AgreementVO;
import za.co.liberty.agreement.client.vo.PropertyVO;
import za.co.liberty.agreement.client.vo.RequestVO;
import za.co.liberty.agreement.common.AgreementObjectReference;
import za.co.liberty.agreement.common.enums.PropertyKindEnumeration;
import za.co.liberty.agreement.common.enums.RequestKindEnumeration;
import za.co.liberty.agreement.common.enums.RequestStatusEnumeration;
import za.co.liberty.agreement.common.enums.RoleKindEnumeration;
import za.co.liberty.agreement.common.exceptions.KindNotFoundException;
import za.co.liberty.agreement.common.exceptions.LogicExecutionException;
import za.co.liberty.agreement.common.exceptions.LogicExecutionValidationException;
import za.co.liberty.agreement.common.exceptions.OnlyActualNotFoundException;
import za.co.liberty.agreement.common.exceptions.ProductNotFoundException;
import za.co.liberty.agreement.process.AgreementManagerBPO;
import za.co.liberty.agreement.process.AgreementManagerBPOHome;
import za.co.liberty.business.agreement.AgreementManagement.Broadcast_Action;
import za.co.liberty.business.agreement.IAgreementManagement;
import za.co.liberty.business.agreement.IConsCodeManagement;
import za.co.liberty.business.agreement.ISpecManagment;
import za.co.liberty.business.agreement.IValidAgreementValuesFactory;
import za.co.liberty.business.agreement.RequestToAgreementPropertyMapping;
import za.co.liberty.business.agreement.builder.AgreementDTOBuildProfile;
import za.co.liberty.business.agreement.builder.IAgreementDTOBuilder;
import za.co.liberty.business.agreement.validator.IAgreementValidator;
import za.co.liberty.business.broadcast.IAgreementIntegrationController;
import za.co.liberty.business.common.IBusinessUtilitiesBean;
import za.co.liberty.business.converter.IAgreementConverter;
import za.co.liberty.business.converter.IAgreementPropertyConverter;
import za.co.liberty.business.guicontrollers.IContextManagement;
import za.co.liberty.business.guicontrollers.partymaintenance.IPartyMaintenanceController;
import za.co.liberty.business.guicontrollers.partymaintenance.PartyMaintenanceController.PartyRequestDetails;
import za.co.liberty.business.party.IPartyManagement;
import za.co.liberty.business.proxy.context.IContextProxy;
import za.co.liberty.business.request.IGuiRequestManagement;
import za.co.liberty.business.request.IRequestEnquiryManagement;
import za.co.liberty.business.security.ISecurityManagement;
import za.co.liberty.business.template.IFranshiseTemplateManagement;
import za.co.liberty.business.userprofiles.IProfileManagement;
import za.co.liberty.common.context.ComponentContext;
import za.co.liberty.common.domain.ApplicationContext;
import za.co.liberty.common.domain.CurrencyAmount;
import za.co.liberty.common.domain.ObjectReference;
import za.co.liberty.common.domain.Percentage;
import za.co.liberty.common.domain.TypeVO;
import za.co.liberty.common.enums.PoolDrawOptionsEnum;
import za.co.liberty.common.exceptions.businessexceptions.InvalidConformanceTypeException;
import za.co.liberty.database.enums.DatabaseEnumHelper;
import za.co.liberty.dto.agreement.AgencyPoolAccountDetailDTO;
import za.co.liberty.dto.agreement.AgreementCodesDTO;
import za.co.liberty.dto.agreement.AgreementDTO;
import za.co.liberty.dto.agreement.AgreementHomeRoleDTO;
import za.co.liberty.dto.agreement.AgreementRoleDTO;
import za.co.liberty.dto.agreement.AssociatedAgreementDetailsDTO;
import za.co.liberty.dto.agreement.ConsCodeGenerationDTO;
import za.co.liberty.dto.agreement.IncentiveDetailDTO;
import za.co.liberty.dto.agreement.PaymentSchedulerDTO;
import za.co.liberty.dto.agreement.ProvidentFundDetailDTO;
import za.co.liberty.dto.agreement.RequestDTO;
import za.co.liberty.dto.agreement.maintainagreement.AgreementPartnerRolesGridDTO;
import za.co.liberty.dto.agreement.maintainagreement.AgreementRoleGridDTO;
import za.co.liberty.dto.agreement.maintainagreement.CreateAgreementRequestConfigurationDTO;
import za.co.liberty.dto.agreement.maintainagreement.MaintainAgreementDTO;
import za.co.liberty.dto.agreement.maintainagreement.MaintainAgreementRequestConfigurationDTO;
import za.co.liberty.dto.agreement.maintainagreement.MaintainPartyDTO;
import za.co.liberty.dto.agreement.maintainagreement.ProvidentFundBeneficiariesDTO;
import za.co.liberty.dto.agreement.maintainagreement.ProvidentFundBeneficiaryDetailsDTO;
import za.co.liberty.dto.agreement.maintainagreement.ProvidentFundRequestDetailDTO;
import za.co.liberty.dto.agreement.maintainagreement.SalesCategoryDTO;
import za.co.liberty.dto.agreement.maintainagreement.TerminateAgreementRequestConfiguration;
import za.co.liberty.dto.agreement.maintainagreement.ValidAgreementValuesDTO;
import za.co.liberty.dto.agreement.maintainagreement.fais.FAISLicensePanelGridDTO;
import za.co.liberty.dto.agreement.payroll.FixedDeductionDTO;
import za.co.liberty.dto.agreement.payroll.FixedEarningDTO;
import za.co.liberty.dto.agreement.properties.BankingDetailsHistoryDTO;
import za.co.liberty.dto.agreement.properties.CostCenterDTO;
import za.co.liberty.dto.agreement.properties.DistributionDetailDTO;
import za.co.liberty.dto.agreement.properties.DistributionTemplateDTO;
import za.co.liberty.dto.agreement.properties.DistributionTemplateHistoryDTO;
import za.co.liberty.dto.agreement.properties.FAISLicenseDTO;
import za.co.liberty.dto.agreement.properties.FranchisePoolAccountDTO;
import za.co.liberty.dto.agreement.properties.PartyAccountDetailsDTO;
import za.co.liberty.dto.agreement.properties.PaysToDTO;
import za.co.liberty.dto.agreement.properties.PreauthLimitCategoryDTO;
import za.co.liberty.dto.agreement.properties.PrimaryAgreementDTO;
import za.co.liberty.dto.agreement.properties.PropertyDTO;
import za.co.liberty.dto.agreement.properties.TemporalPropertyDTO;
import za.co.liberty.dto.agreement.request.RaiseGuiRequestResultDTO;
import za.co.liberty.dto.agreement.request.RequestEnquiryResultDTO;
import za.co.liberty.dto.agreement.request.RequestEnquirySearchDTO;
import za.co.liberty.dto.common.IDValueDTO;
import za.co.liberty.dto.common.MonthEndDates;
import za.co.liberty.dto.common.TimePeriod;
import za.co.liberty.dto.contracting.ContractingSearchOptionsDTO;
import za.co.liberty.dto.contracting.ResultAgreementDTO;
import za.co.liberty.dto.contracting.ResultPartyDTO;
import za.co.liberty.dto.databaseenum.FAISSupervisionTypeDBEnumDTO;
import za.co.liberty.dto.gui.templates.DistributionKindGroupRatesDTO;
import za.co.liberty.dto.party.PartyDTO;
import za.co.liberty.dto.party.aqcdetail.AQCDTO;
import za.co.liberty.dto.party.aqcdetail.AQCDetailsWithTypeDTO;
import za.co.liberty.dto.party.aqcdetail.AdvisorQualityCodeDTO;
import za.co.liberty.dto.party.aqcdetail.EffectiveAQCDTO;
import za.co.liberty.dto.party.fais.FAISLicenseCategoryDTO;
import za.co.liberty.dto.party.fais.supervision.FAISCategorySupervisionDTO;
import za.co.liberty.dto.party.medicalaid.MedicalAidDetailDTO;
import za.co.liberty.dto.persistence.party.flow.PanelDetailFLO;
import za.co.liberty.dto.persistence.party.flow.PartyNameAgreementFLO;
import za.co.liberty.dto.rating.SegmentDTO;
import za.co.liberty.dto.spec.ActualLifeCycleStatusDTO;
import za.co.liberty.dto.spec.PropertySpecDTO;
import za.co.liberty.dto.userprofiles.ContextDTO;
import za.co.liberty.dto.userprofiles.ISessionUserProfile;
import za.co.liberty.exceptions.SystemException;
import za.co.liberty.exceptions.data.ConformanceTypeException;
import za.co.liberty.exceptions.data.DataNotFoundException;
import za.co.liberty.exceptions.data.InconsistentDataException;
import za.co.liberty.exceptions.data.QueryTimeoutException;
import za.co.liberty.exceptions.data.ValidationException;
import za.co.liberty.exceptions.error.request.RequestConfigurationException;
import za.co.liberty.exceptions.error.request.RequestException;
import za.co.liberty.exceptions.fatal.CommunicationException;
import za.co.liberty.helpers.util.ComparatorUtil;
import za.co.liberty.helpers.util.ComparatorUtil.ObjectComparisonDifferences;
import za.co.liberty.interfaces.agreements.AgreementKindType;
import za.co.liberty.interfaces.agreements.AgreementStatusReasonType;
import za.co.liberty.interfaces.agreements.AgreementStatusType;
import za.co.liberty.interfaces.agreements.ConsCodeType;
import za.co.liberty.interfaces.agreements.IAgreementDetailFLO;
import za.co.liberty.interfaces.agreements.IAgreementDetailWithMyBankNumFLO;
import za.co.liberty.interfaces.agreements.IPropertyFLO;
import za.co.liberty.interfaces.agreements.PrimaryAgreementDivisionType;
import za.co.liberty.interfaces.agreements.ProjectBaseType;
import za.co.liberty.interfaces.agreements.RoleKindType;
import za.co.liberty.interfaces.agreements.UserActionType;
import za.co.liberty.interfaces.agreements.distribution.DistributionTemplateKindType;
import za.co.liberty.interfaces.agreements.requests.PropertyKindType;
import za.co.liberty.interfaces.agreements.requests.RequestDateType;
import za.co.liberty.interfaces.agreements.requests.RequestKindType;
import za.co.liberty.interfaces.agreements.requests.RequestStatusType;
import za.co.liberty.interfaces.common.ITypeFLO;
import za.co.liberty.interfaces.gui.GuiRequestKindType;
import za.co.liberty.interfaces.party.PartyStatusType;
import za.co.liberty.interfaces.party.PartyType;
import za.co.liberty.interfaces.persistence.agreement.request.IRequestEnquiryRow;
import za.co.liberty.interfaces.persistence.party.flow.IPartyNameAgreementFLO;
import za.co.liberty.interfaces.rating.ci.CIDateType;
import za.co.liberty.interfaces.rating.description.DescriptionKindType;
import za.co.liberty.party.util.Constants;
import za.co.liberty.persistence.agreement.IAgreementEntityManager;
import za.co.liberty.persistence.agreement.entity.DateRange;
import za.co.liberty.persistence.agreement.entity.fastlane.AgreementStatusAndStatusReasonFLO;
import za.co.liberty.persistence.agreement.entity.fastlane.PropertyFLO;
import za.co.liberty.persistence.agreement.entity.fastlane.TemporalPropertyFLO;
import za.co.liberty.persistence.party.IPartyEntityManager;
import za.co.liberty.persistence.party.entity.fastlane.PartyProfileFLO;
import za.co.liberty.persistence.party.entity.fastlane.PartyUacfIdFLO;
import za.co.liberty.persistence.rating.IBankCodesEntityManager;
import za.co.liberty.persistence.rating.ICICalculationDateEntityManager;
import za.co.liberty.persistence.rating.ICostCenterEntityManager;
import za.co.liberty.persistence.rating.IDescriptionEntityManager;
import za.co.liberty.persistence.rating.IDistributionDetailsEntityManager;
import za.co.liberty.persistence.rating.IPreauthLimitCategoryEntityManager;
import za.co.liberty.persistence.rating.IRatingEntityManager;
import za.co.liberty.persistence.rating.ISalesCategoriesMapEntityManager;
import za.co.liberty.persistence.rating.entity.BankCode;
import za.co.liberty.persistence.rating.entity.CostCenter;
import za.co.liberty.persistence.rating.entity.Description;
import za.co.liberty.persistence.rating.entity.DistributionDetails;
import za.co.liberty.persistence.rating.entity.PreauthLimitCategory;
import za.co.liberty.persistence.rating.entity.SalesCategoriesMapEntity;
import za.co.liberty.persistence.rating.entity.fastlane.CalculationDateFLO;
import za.co.liberty.security.UserSecurityProfile;
import za.co.liberty.security.bpo.SecurityContextBPOHome;
import za.co.liberty.security.exceptions.SecurityException;
import za.co.liberty.srs.type.SRSType;
import za.co.liberty.srs.util.DateUtil;
import za.co.liberty.srs.util.agreement.TaxBasisConstants;
import za.co.liberty.xml.queries.Query;
import za.co.liberty.xml.queries.QueryHelper;
/**
 * This class represents the implementation of the
 * {@link IAgreementGUIController} interface, to provide a business delegate
 * service to the GUI to store and retrieve business data.
 * 
 * @author kxd1203
 * 
 */
@Stateless
public class AgreementGUIController implements IAgreementGUIController {

	private static Logger logger = Logger
			.getLogger(AgreementGUIController.class.getName());

	

	private Comparator<DistributionDetailDTO> distributionDetailComparator = new Comparator<DistributionDetailDTO>() {
		public int compare(DistributionDetailDTO o1, DistributionDetailDTO o2) {
			if (o1 == null && o2 == null) {
				return 0;
			}
			if (o1 == null) {
				return 1;
			}
			if (o2 == null) {
				return 0;
			}
			if (o1.getDistributionKind() == null
					&& o2.getDistributionKind() == null) {
				return 0;
			}
			if (o1.getDistributionKind() == null) {
				return 1;
			}
			if (o2.getDistributionKind() == null) {
				return -1;
			}
			return o1.getDistributionKind().compareTo(o2.getDistributionKind());
		}
	};

	// RXS 1408 ADDED for Hierarchy FR3.2 Sales Category - RAVISH SEHGAL
	public List<SalesCategoryDTO> getDivisions() {

		List<SalesCategoryDTO> divisions = new ArrayList<SalesCategoryDTO>();
		SalesCategoryDTO dto =  new SalesCategoryDTO();
		
		dto.setDivision("Agent");
		divisions.add(dto);
		
		return divisions;
	}

	// RXS 1408 ADDED for Hierarchy FR3.2 Sales Category - RAVISH SEHGAL
	public List<SalesCategoryDTO> getSalesCategories(String srsDivision) {
		List<SalesCategoriesMapEntity> tempSalesCategories =  new ArrayList<SalesCategoryDTO>();
//		SalesCategoryDTO dto = new SalesCategoryDTO();
//		for (SalesCategoriesMapEntity category : tempSalesCategories) {
//			dto = new SalesCategoryDTO();
//			dto.setSalesCategory(category.getSalesCategory());
//			dto.setAgreementKind(category.getAgreementKind());
//			dto.setAgreementKindId(category.getAgreementKindId());
//			salesCategories.add(dto);
//		}
		return salesCategories;
	}

	// RXS 1408 ADDED for Hierarchy FR3.2 Sales Category - RAVISH SEHGAL
	public List<SalesCategoryDTO> getKindTypeDescription(
			List<SalesCategoryDTO> salesCategories, String selectedSalesCategory) {
		String value = "";
		MultiMap multiMap = new MultiValueMap();
		SalesCategoryDTO dto = new SalesCategoryDTO();
		List<SalesCategoryDTO> agreementTypeList = new ArrayList<SalesCategoryDTO>();
		for (SalesCategoryDTO listItr : salesCategories) {
			multiMap.put(listItr.getSalesCategory(), listItr.getAgreementKind());
			multiMap.put(listItr.getSalesCategory(),
					listItr.getAgreementKindId());
		}
		Set<String> keys = multiMap.keySet();
		for (String key : keys) {
			if (selectedSalesCategory.equalsIgnoreCase(key)) {
				value = multiMap.get(key).toString();
				value = value.replace("[", "");
				value = value.replace("]", "");
				String[] tempValues = value.split(",");
				String agreementKind = tempValues[0];
				String agreementKindId = tempValues[1].trim();
				dto = new SalesCategoryDTO();
				dto.setAgreementKind(agreementKind);
				dto.setAgreementKindId(Integer.parseInt(agreementKindId));
				agreementTypeList.add(dto);
			}
		}
		return agreementTypeList;
	}

	// RXS 1408 ADDED for Hierarchy FR3.2 Sales Category - RAVISH SEHGAL
	public SalesCategoryDTO getSalesCategoryScreensMapping(
			String salesCategory, int agreementKindId, String partyType) {
		List<SalesCategoriesMapEntity> tempSalesCategoryScreensMapping = null;
//		tempSalesCategoryScreensMapping = salesCategoriesMapEntityManager
//				.getSalesCategoryScreensMapping(salesCategory, agreementKindId);
//		SalesCategoryDTO screenMappingDTO = new SalesCategoryDTO();
//		for (SalesCategoriesMapEntity category : tempSalesCategoryScreensMapping) {
//			screenMappingDTO = new SalesCategoryDTO();
//			screenMappingDTO.setSalesCategory(category.getSalesCategory());
//			screenMappingDTO.setAgreementKindId(category.getAgreementKindId());
//			screenMappingDTO.setAgreementKind(category.getAgreementKind());
//			screenMappingDTO.setDivisionExtReference(category
//					.getDivisionExtReference());
//			screenMappingDTO.setPartyType(category.getPartyType());
//			screenMappingDTO
//					.setPartyTypeDetails(category.getPartyTypeDetails());
//			screenMappingDTO.setAddressDetails(category.getAddressDetails());
//			screenMappingDTO
//					.setAgreementDetails(category.getAgreementDetails());
//			screenMappingDTO.setDistributionAndPaysTo(category
//					.getDistributionAndPaysTo());
//			screenMappingDTO.setAgreementHierarchy(category
//					.getAgreementHierarchy());
//			screenMappingDTO.setMedicalAidDetails(category
//					.getMedicalAidDetails());
//			screenMappingDTO.setAssociatedCodes(category.getAssociatedCodes());
//			screenMappingDTO.setProvidentFund(category.getProvidentFund());
//			screenMappingDTO
//					.setPaymentScheduler(category.getPaymentScheduler());
//			screenMappingDTO.setAssociatedAgreements(category
//					.getAssociatedAgreements());
//			screenMappingDTO.setFAISDetails(category.getFAISDetails());
//			screenMappingDTO.setAQCDetails(category.getAQCDetails());
//			screenMappingDTO
//					.setIncentiveDetails(category.getIncentiveDetails());
//			screenMappingDTO.setFranchiseIntoPool(category
//					.getFranchiseIntoPool());
//			screenMappingDTO.setFICADetails(category.getFICADetails());
//		}
		return screenMappingDTO;
	}

	// RXS 1408 ADDED for Hierarchy FR3.2 Sales Category - RAVISH SEHGAL
	public List<String> getValidSalesCategories(int kind, String division,
			boolean modifyEditState) {
		List<String> ret = null;
		if (!modifyEditState) {
			// Required for Agreement Details screen for autoselection value
			// selected at the 1st screen.
			ret = salesCategoriesMapEntityManager.getAllSalesCategories();
		} else {
			// Required for Maintaining an agreement
			ret = salesCategoriesMapEntityManager.getFilteredSalesCategories(
					division, kind);
			if (ret.size() == 0) {
				ret = salesCategoriesMapEntityManager
						.getFilteredSalesCategoriesOnKind(kind);
			}
		}
		return ret;
	}

	public ValidAgreementValuesDTO getValidAgreementValues(
			AgreementDTO agreement) {
		return getValidAgreementValues(agreement, null,
				AgreementDTOBuildProfile.ALL);
	}

	public ValidAgreementValuesDTO getValidAgreementValues(
			AgreementDTO agreement, ValidAgreementValuesDTO validValues,
			AgreementDTOBuildProfile loadProfile) {
		ValidAgreementValuesDTO ret = validValues == null ? new ValidAgreementValuesDTO()
				: validValues;
		if (loadProfile == null) {
			loadProfile = AgreementDTOBuildProfile.CORE;
		}
		if (agreement == null) {
			return ret;
		}
		if (loadProfile.equals(AgreementDTOBuildProfile.ALL)
				|| loadProfile.equals(AgreementDTOBuildProfile.CORE)) {
			/**
			 * LOAD CORE VALID VALUES
			 */
			// Added pks2802 for Payment Scheduler
			if (ret.getValidPreIssueStatus() == null) {
				ret.setValidPreIssueStatus(validAgreementValuesFactory
						.getValidPreIssueStatus());
			}

			/**
			 * pks2802 Set the Valid CommKinds from rating
			 */
			if (ret.getValidCommissionKinds() == null) {
				ret.setValidCommissionKinds(validAgreementValuesFactory
						.getValidCommKindList());
			}
			/**
			 * pks2802 Set the Valid CommKinds from rating for Associated
			 * Agreements
			 */
			if (ret.getValidCommKindsForAssociatedAgmt() == null) {
				ret.setValidCommKindsForAssociatedAgmt(validAgreementValuesFactory
						.getValidCommKindListForAssAgmt());
			}
		}

		if (loadProfile.equals(AgreementDTOBuildProfile.ALL)
				|| loadProfile
						.equals(AgreementDTOBuildProfile.MAINTAIN_AGREEMENT)) {
			List<ActualLifeCycleStatusDTO> validTransitions = getValidAgreementStatusList(agreement);
			ret.setValidTransitionsForStatus(validTransitions);
			/**
			 * Valid Status Reasons
			 */
			if (ret.getValidStatusReason() == null) {
				ret.setValidStatusReason(validAgreementValuesFactory
						.getValidStatusReason());
			}

			/**
			 * Valid Sales Categories - //RXS 1408 ADDED for Hierarchy FR3.2
			 * salesCategory - RAVISH SEHGAL
			 */
			/*
			 * if (ret.getValidSalesCategory()== null) { //PSD Values not
			 * required as it may be updated at a later stage so it has to be in
			 * dbase. //ret.setValidSalesCategory(validAgreementValuesFactory.
			 * getValidSalesCategory());
			 * ret.setValidSalesCategory(salesCategoriesMapEntityManager
			 * .getAllSalesCategories()); }
			 */

			/**
			 * Valid LBF Remuneration Categories -//MZL 2611 ADDED for FR2.8.2
			 * LBF Remuneration Category - MOHAMMED LORGAT
			 */
			if (ret.getValidLBFRemunerationCategory() == null) {
				ret.setValidLBFRemunerationCategory(validAgreementValuesFactory
						.getValidLBFRemunerationCategory());
			}
			/**
			 * Valid Production Club Statuses
			 */
			if (ret.getValidProductionClubStatus() == null) {
				ret.setValidProductionClubStatus(validAgreementValuesFactory
						.getValidProductionClubStatus());
			}
			if (ret.getValidBrokerConsultantProductionClubStatus() == null) {
				ret.setValidBrokerConsultantProductionClubStatus(validAgreementValuesFactory
						.getValidBrokerConsultantProductionClubStatus());
			}
			/**
			 * Valid Manpower
			 */
			if (ret.getValidManpower() == null) {
				ret.setValidManpower(validAgreementValuesFactory
						.getValidManpower());
			}

			if (ret.getValidDirectManpower() == null) {
				ret.setValidDirectManpower(validAgreementValuesFactory
						.getValidDirectManpower());
			}
			/**
			 * Valid Early Debits Reason
			 */
			if (ret.getValidEarlyDebitsReason() == null) {
				ret.setValidEarlyDebitsReason(validAgreementValuesFactory
						.getValidEarlyDebitsReason(agreement));
			}
			/**
			 * Valid Dedicated SBFCConsultantType
			 */
			if (ret.getValidDedicatedSBFCConsultantType() == null) {
				ret.setValidDedicatedSBFCConsultantType(validAgreementValuesFactory
						.getValidDedicatedSBFCConsultantType());
			}
			/**
			 * Valid Titular Level
			 */
			if (ret.getValidTitularLevel() == null) {
				ret.setValidTitularLevel(validAgreementValuesFactory
						.getValidTitularLevel());
			}
			/**
			 * Valid Primary Company Contracted To
			 */
			if (ret.getValidPrimaryCompanyContractedTo() == null) {
				ret.setValidPrimaryCompanyContractedTo(validAgreementValuesFactory
						.getValidPrimaryCompanyContractedTo());
			}
			/**
			 * Valid support type
			 */
			if (ret.getValidSupportType() == null) {
				ret.setValidSupportType(validAgreementValuesFactory
						.getValidSupportType());
			}
			/**
			 * Valid segment
			 */
			if (ret.getValidSegment() == null) {
				ret.setValidSegment(validAgreementValuesFactory
						.getValidSegment());
			}
			/**
			 * Valid BBF Groups
			 */
			if (ret.getValidBBFGroups() == null) {
				ret.setValidBBFGroups(validAgreementValuesFactory
						.getValidBBFGroups());
			}
			/**
			 * Valid CostCenter values
			 */
			// if (ret.getValidCostCenter()==null) {
			// ret.setValidCostCenter(
			// validAgreementValuesFactory.getValidCostCenter());
			// }
			/**
			 * Default Preauth Category Limit
			 */
			ret.setDefaultPreauthLimitCategory(getDefaultPreauthLimitCategory(agreement));
			/**
			 * Set overridden Preauth Category Limit
			 */
			if (ret.getOverriddenPreauthLimitCategory() == null) {
				ret.setOverriddenPreauthLimitCategory(validAgreementValuesFactory
						.getOverriddenPreauthLimitCategory());
			}

			if (ret.getValidValuesForFitpropSegment() == null) {
				ret.setValidValuesForFitpropSegment(validAgreementValuesFactory
						.getValidValuesForFitAndProperSegment());
			}

			if (ret.getValidValuesForManualProductionClubStatus() == null) {
				ret.setValidValuesForManualProductionClubStatus(validAgreementValuesFactory
						.getValidValuesForManualProductionClubStatus());
			}

			if (ret.getAllProductionClubStatuses() == null) {
				ret.setAllProductionClubStatuses(validAgreementValuesFactory
						.getAllProductionClubStatuses());
			}
			
			if (ret.getValidHasMedicalDates() == null) {
				ret.setValidHasMedicalDates(validAgreementValuesFactory.getValidHasMedicalDates(agreement));
			}
		}
		return ret;
	}

	/**
	 * Proxy method used for in gui lookups of default preauth limit category
	 */
	public PreauthLimitCategoryDTO getDefaultPreauthLimitCategory(
			AgreementDTO agreement) {
		return validAgreementValuesFactory
				.getDefaultPreauthLimitCategory(agreement);
	}

	private List<ActualLifeCycleStatusDTO> getValidAgreementStatusList(
			AgreementDTO agreement) {
		/**
		 * Valid Status Transitions
		 */
		List<ActualLifeCycleStatusDTO> validTransitions = new ArrayList<ActualLifeCycleStatusDTO>();
		if (agreement.getCurrentStatus() != null) {
			/**
			 * Use a set to ensure that no duplicate entries are added to the
			 * set, and then convert back to a usable list
			 */
			Set<ActualLifeCycleStatusDTO> statusTransitionsSet = new HashSet<ActualLifeCycleStatusDTO>();
			List<ActualLifeCycleStatusDTO> validTransitionsForStatus = validAgreementValuesFactory
					.getValidTransitionsForStatusId(agreement
							.getCurrentStatus().getSpecId());
			if (validTransitionsForStatus != null) {
				statusTransitionsSet.addAll(validTransitionsForStatus);
				statusTransitionsSet.add(agreement.getCurrentStatus());
			}
			// /**
			// * QC7864 - GUI rewrite - Maintenance on terminated agreement
			// * Remove terminated from the list of valid agreement status,
			// * as this is no longer set using maintain, but rather through
			// * dedicated behaviour logic
			// *
			// * Only remove terminated status, if the agreement status is not
			// * currently Terminated
			// */
			// if
			// (!agreement.getCurrentStatus().getName().equalsIgnoreCase("Terminated"))
			// {
			// for (Iterator<ActualLifeCycleStatusDTO> iter =
			// statusTransitionsSet.iterator();
			// iter.hasNext();) {
			// ActualLifeCycleStatusDTO current = iter.next();
			// if (current.getName().equalsIgnoreCase("Terminated")) {
			// iter.remove();
			// }
			// }
			// }
			/**
			 * Set the list of valid transitions
			 */
			validTransitions.addAll(statusTransitionsSet);
		}
		return validTransitions;
	}

	public AgreementDTO getAgreementDTOForObjectOID(long id)
			throws CommunicationException, DataNotFoundException {
		return agreementManagement.getAgreementWithObjectOID(id);
	}

	/**
	 * Loading deferred properties/DTOs for the AgreementDTO.
	 * 
	 * Any properties or DTOs that have deferred loading that have not yet been
	 * loaded for the specified requests will be loaded into the specified
	 * AgreementDTO object
	 * 
	 * @throws DataNotFoundException
	 * @throws CommunicationException
	 * 
	 */
	public AgreementDTO loadDeferredDataForRequest(AgreementDTO agreementDTO,
			AgreementDTO beforeImage,
			ValidAgreementValuesDTO validAgreementValues,
			RequestKindType... requestKindTypes) throws CommunicationException,
			DataNotFoundException {
		for (RequestKindType requestKind : requestKindTypes) {
			if (agreementDTO.getDeferredLoadingCompleted()
					.contains(requestKind)) {
				/**
				 * SKIP this request kind - deferred loading already completed
				 */
				continue;
			}
			// /**
			// * Process deferred properties
			// */
			// processDeferredProperties(agreementDTO,requestKind);
			// /**
			// * load agreement related data
			// */
			AgreementDTOBuildProfile profile = AgreementDTOBuildProfile
					.getLoadProfileForRequestKind(requestKind);
			agreementDTOBuilder.buildAgreementDTO(agreementDTO, beforeImage,
					validAgreementValues, profile);
		}
		return agreementDTO;
	}

	/**
	 * Reloads the values for a request kind. Exactly the same as deferred
	 * except that it forces a load.
	 * 
	 * @param agreementDTO
	 * @param validAgreementValues
	 * @param requestKindTypes
	 * @return
	 */
	public AgreementDTO loadValidValuesForRequest(AgreementDTO agreementDTO,
			ValidAgreementValuesDTO validAgreementValues,
			RequestKindType... requestKindTypes) throws CommunicationException,
			DataNotFoundException {

		for (RequestKindType requestKind : requestKindTypes) {
			AgreementDTOBuildProfile profile = AgreementDTOBuildProfile
					.getLoadProfileForRequestKind(requestKind);
			agreementDTOBuilder.buildValidAgreementValuesOnly(agreementDTO,
					validAgreementValues, profile, true);
		}
		return agreementDTO;

	}

	public AgreementDTO loadDeferredValidValuesForRequest(
			AgreementDTO agreementDTO,
			ValidAgreementValuesDTO validAgreementValues,
			RequestKindType... requestKindTypes) throws CommunicationException,
			DataNotFoundException {
		for (RequestKindType requestKind : requestKindTypes) {
			if (agreementDTO.getDeferredLoadingCompleted()
					.contains(requestKind)) {
				/**
				 * SKIP this request kind - deferred loading already completed
				 */
				continue;
			}
			AgreementDTOBuildProfile profile = AgreementDTOBuildProfile
					.getLoadProfileForRequestKind(requestKind);
			agreementDTOBuilder.buildValidAgreementValuesOnly(agreementDTO,
					validAgreementValues, profile);
		}
		return agreementDTO;
	}

	/**
	 * Process any deferred loading of properties on the AgreementDTO
	 * 
	 * @param agreementDTO
	 * @param kindType
	 */
	@SuppressWarnings("unchecked")
	private void processDeferredProperties(AgreementDTO agreementDTO,
			RequestKindType kindType) {
		/**
		 * Do deferred loading of properties if any is required, and register
		 * the request as having being completed for deferred loading
		 */
		agreementDTO.getDeferredLoadingCompleted().add(kindType);
		RequestToAgreementPropertyMapping propertyKindMapping = RequestToAgreementPropertyMapping
				.getMappingForRequestKind(kindType.getRequestKind());
		if (propertyKindMapping == null) {
			return;
		}
		List<PropertyKindType> propertyKindList = Arrays
				.asList(propertyKindMapping.getPropertyKindTypes());
		/**
		 * Iterate through the agreement DTO properties, if any are listed in
		 * the request/property mapping then convert them
		 */
		for (PropertyDTO property : agreementDTO.getAllProperties()) {
			if (propertyKindList.contains(property.getPropertyKind())) {
				agreementPropertyConverter.processPropertyForAgreementDTO(
						agreementDTO, property);
			}
		}
	}

	public List<CostCenterDTO> getCostCenterWithPartialValue(String costCenter) {
		List<CostCenterDTO> ret = new ArrayList<CostCenterDTO>();
		List<CostCenter> costCenterList = costCenterManager
				.getCostCentersForPartialValue(costCenter);
		if (costCenterList != null) {
			for (CostCenter cost : costCenterList) {
				ret.add(convertCostCenterToCostCenterDTO(cost));
			}
		}
		return ret;
	}

	public CostCenterDTO getCostCenterForValue(String costCenter) {
		CostCenterDTO ret = null;
		CostCenter cost = costCenterManager.getCostCenterForValue(costCenter);
		if (cost != null) {
			ret = convertCostCenterToCostCenterDTO(cost);
		}
		return ret;
	}

	protected CostCenterDTO convertCostCenterToCostCenterDTO(CostCenter cost) {
		if (cost == null) {
			return null;
		} else {
			return new CostCenterDTO((int) cost.getNumber(),
					cost.getCostCenter(), cost.getDescription());
		}
	}

	@SuppressWarnings("unchecked")
	public List<PropertySpecDTO> getPropertySpecsForAgreementSpecification(
			long specificationID) throws CommunicationException {
		return specManagement
				.getPropertySpecsForAgreementSpecification(specificationID);
	}

	public PreauthLimitCategoryDTO getPreauthLimitCategoryByID(String id) {
		PreauthLimitCategoryDTO ret = null;
		if (id == null) {
			return ret;
		}
		PreauthLimitCategory category = preauthLimitManager
				.getPreauthLimitCategoryByID(id);
		if (category == null) {
			return ret;
		}
		ret = new PreauthLimitCategoryDTO(category.getCategory(),
				category.getPropertyKindId(), category.getPreauthLimit());
		return ret;
	}

	public PartyAccountDetailsDTO getPartyAccountDetails(long agreementNumber)
			throws CommunicationException {
		PartyAccountDetailsDTO ret = new PartyAccountDetailsDTO();
		ret.setAgreementNumber(agreementNumber);
		try {
			ResultPartyDTO resultParty = partyManagement
					.findPartyIntermediaryWithAgreementNr(agreementNumber);
			if (resultParty != null) {
				ret.setName(resultParty.getName());
			}
			ResultAgreementDTO resultAgreement = agreementManagement
					.findAgreementWithSRSAgreementNr(agreementNumber);
			if (resultAgreement != null) {
				ret.setConsultantCode(resultAgreement.getConsultantCode());
				ret.setStatus(resultAgreement.getAgreementStatus());
			}
		} catch (CommunicationException e) {
			throw e;
		} catch (DataNotFoundException e) {
			logger.fatal("Could not find the party for the specified agreement number: "
					+ agreementNumber);
			return null;
		}
		return ret;
	}

	@SuppressWarnings("unchecked")
	public List<DistributionDetailDTO> getDistributionDetails(
			int agreementKind, DistributionTemplateDTO distributionTemplate) {
		@SuppressWarnings("unused")
		List<DistributionDetails> ret = null;
		if (distributionTemplate == null
				|| distributionTemplate.getId() == null) {
			return Collections.EMPTY_LIST;
		}
		/**
		 * Get the distribution template kind type for the specified agreement
		 * type
		 */
		DistributionTemplateKindType templateKind = DistributionTemplateKindType
				.getKindForAgreementKind(agreementKind);
		if (templateKind == null) {
			return Collections.EMPTY_LIST;
		}
		return getDistributionDetails(distributionTemplate.getId(),
				templateKind.getTemplateKind().getKind(), templateKind
						.getDescriptionKind().getKind());
	}

	/**
	 * Get distribution details for the specified template id
	 * 
	 * @param templateId
	 *            the template id of the template
	 * @return all distribution details for the template
	 */
	private List<DistributionDetailDTO> getDistributionDetails(int templateId,
			int templateDescriptionKind, int distribKindDescriptionKind) {
		List<DistributionDetailDTO> ret = new ArrayList<DistributionDetailDTO>();
		List<DistributionDetails> list = distributionDetailsManager
				.getDistributionDetailsForTemplateID(templateId,
						templateDescriptionKind, distribKindDescriptionKind);
		if (list != null) {
			for (DistributionDetails detail : list) {
				ret.add(new DistributionDetailDTO(detail
						.getDistribKindDescription(), detail.getFactor(),
						detail.getPaymentSchedule()));
			}
		}
		Collections.sort(ret, distributionDetailComparator);
		return ret;
	}

	@SuppressWarnings("unchecked")
	public List<RequestDTO> getRequestsPendingAuthorisation(
			AgreementDTO agreementDTO) {
		if (agreementDTO == null || agreementDTO.getId() == 0) {
			return Collections.EMPTY_LIST;
		}
		RequestStatusEnumeration[] statuses = new RequestStatusEnumeration[] { RequestStatusEnumeration.REQUIRESAUTHORISATION };
		RequestKindEnumeration[] kinds = new RequestKindEnumeration[] {
				RequestKindEnumeration.MAINTAININTERMEDIARYAGREEMENT,
				RequestKindEnumeration.MAINTAINDISTRIBUTIONDETAILS };
		try {
			List<RequestDTO> requests = agreementManagement
					.getRequestsForAgreementStatusAndKinds(
							new ApplicationContext(), agreementDTO.getId(),
							kinds, statuses);
			if (requests == null) {
				return Collections.EMPTY_LIST;
			}
			return requests;
		} catch (DataNotFoundException e) {
			throw new CommunicationException(
					"Could not find requests for the specified agreement ["
							+ agreementDTO.getId() + "]", e);
		}
	}

	/**
	 * Setup an {@link AgreementDTO} for a new agreement.
	 * 
	 * @param agreementDTO
	 *            the agreement, populated with kind and specification id
	 * @return the {@link AgreementDTO}, setup for a new agreement
	 */
	@SuppressWarnings("unchecked")
	public AgreementDTO createNewAgreementDTO(AgreementKindType kind) {
		if (kind == null) {
			throw new IllegalArgumentException(
					"AgreementKindType must be specified");
		}
		AgreementDTO agreementDTO = new AgreementDTO();
		agreementDTO.setAssociatedCodes(new AgreementCodesDTO());
		if (kind == AgreementKindType.AGENT) {
			agreementDTO.setProvidentFundDetail(new ProvidentFundDetailDTO());
		}
		agreementDTO.setFaisLicense(new FAISLicenseDTO());// getNewFaisLicenseDTO(kind));//new
															// FAISLicenseDTO());
		agreementDTO.setFranchisePoolAccount(new FranchisePoolAccountDTO());
		agreementDTO.setPaymentSchedulerDTO(new PaymentSchedulerDTO());
		agreementDTO.getPaymentSchedulerDTO().setExistingScheduler(false);
		/**
		 * MUST SET ACTION TYPE ON PAYMENT SCHEDULER TO ADD, SO THAT THE PAYMENT
		 * SCHEDULER AND ROLES ARE CREATED
		 */
		agreementDTO.getPaymentSchedulerDTO().setActionTypeForCalScheduler(
				UserActionType.ADD);
		agreementDTO.setSpecificationId(kind.getSpecificationId());
		agreementDTO.setKind(kind.getKind());
		// For Differential pricing-08/10/10-pks2802
		agreementDTO.setAdvisorQualityCodeDTO(new AdvisorQualityCodeDTO());
		agreementDTO.setIncludeInManpowerReporting(new Boolean(false));
		// SSM2707 Added for FR3.5 Primary Agreement SWETA MENON
		agreementDTO.setPrimaryAgreement(new Boolean(false));
		agreementDTO.setPrimaryAgreementDTO(new PrimaryAgreementDTO());
		// RXS1408 - Hierarchy FR3.6 EmployeeNumber
		// agreementDTO.setEmployeeNumber(0);
		// SSM2707 Sweta Menon Agency Pool 11/10/2017
		agreementDTO
				.setAgencyPoolAccountDetailDTO(new AgencyPoolAccountDetailDTO());
		// ZZT2108 Provident Fund Beneficiaries
		ProvidentFundBeneficiariesDTO providentFundBeneficiariesDTO = new ProvidentFundBeneficiariesDTO();
		providentFundBeneficiariesDTO.setProvidentFundBeneficiaryDetailsList(new ArrayList<ProvidentFundBeneficiaryDetailsDTO>());
		agreementDTO.setProvidentFundBeneficiariesDTO(providentFundBeneficiariesDTO);
		/**
		 * Set the current status to InProgress
		 */
		List<ActualLifeCycleStatusDTO> actualLifeCycleStatusList = specManagement
				.getActualLifeCycleStatusesForAgreementSpecification(agreementDTO
						.getSpecificationId());
		if (actualLifeCycleStatusList != null)
			for (ActualLifeCycleStatusDTO actualLifeCycleStatus : actualLifeCycleStatusList) {
				if (actualLifeCycleStatus.getName().equals("InProgress")) {
					agreementDTO.setCurrentStatus(actualLifeCycleStatus);
					break;
				}
			}
		/**
		 * Set the preauth limit category
		 */
		agreementDTO.setPreauthLimitCategory(null);
		PreauthLimitCategoryDTO defaultCategory = getDefaultPreauthLimitCategory(agreementDTO);
		agreementDTO.setPreauthLimitCategory(defaultCategory);
		/**
		 * Get property specs for the agreement type, and populate agreement dto
		 * from properties derived from the property spec defaults
		 */
		List<PropertySpecDTO> specs = getPropertySpecsForAgreementSpecification(agreementDTO
				.getSpecificationId());
		try {
			agreementConverter.populateAgreementDTO(agreementDTO, null, specs);
			agreementConverter
					.processPropertyConversionForPopulatedAgreement(agreementDTO);
		} catch (CommunicationException e) {
			SystemException sys = new SystemException();
			sys.initCause(e);
			throw sys;
		} catch (ConformanceTypeException e) {
			SystemException sys = new SystemException();
			sys.initCause(e);
			throw sys;
		}

		return agreementDTO;
	}

	// FAISLicenseDTO getNewFaisLicenseDTO(AgreementKindType kind) {
	// FAISLicenseDTO ret = new FAISLicenseDTO();
	// Long alternatePartyOid = null;
	// switch (kind) {
	// /**
	// * don't lookup 3rd party details for stop order broker or broker
	// *
	// * Brokers and Stop Order Brokers to populate with existing license
	// * details from Party . If no party license details found, user
	// * must be forced to capture.
	// */
	// case BROKER:
	// case STOP_ORDER_BROKER:
	// case BROKER_BRANCH_FRANCHISE: //MOVED TO INDEPENDANT FOR REGULATORY
	// PURPOSES
	// break;
	// /**
	// * Commission Only, Salaried Contractors, Salaried Employees to use
	// * Capital Alliance’s FAIS licence details
	// */
	// case LIBERTY_ATWORK_COMMISSIONONLY:
	// case LIBERTY_ATWORK_SALARIEDCONTRACTOR:
	// case LIBERTY_ATWORK_SALARIEDEMP: alternatePartyOid = 268958L; break;
	// /**
	// * Agents , Franchise Intermediary , Broker Consultants , Direct ,
	// * BBF Intermediary & Franchise Manager to use Liberty’s FAIS licence
	// details
	// */
	// case AGENT:
	// case BROKER_CONSULTANT:
	// case DIRECT:
	// case FRANCHISE:
	// case FRANCHISE_MANAGER: alternatePartyOid = 5L; break;
	// //default : do nothing
	// default: break;
	// }
	// if (alternatePartyOid != null) {
	// FAISLicenseDTO tiedFAISLicense = null;
	// if (alternatePartyOid == 5L) {
	// tiedFAISLicense = agreementManagement
	// .getLibertyPartyFaisLicenseDTO(LibertyFAISLicenseParty.LIBERTY);
	// } else if (alternatePartyOid == 268958L) {
	// tiedFAISLicense = agreementManagement
	// .getLibertyPartyFaisLicenseDTO(LibertyFAISLicenseParty.CAPITAL_ALLIENCE);
	// }
	// if (tiedFAISLicense != null) {
	// ret = tiedFAISLicense;
	// }
	// }
	// return ret;
	// }

	/**
	 * Get a PartyDTO using its id
	 * 
	 * @param partyOID
	 * @return
	 * @throws DataNotFoundException
	 * @throws CommunicationException
	 */
	public PartyDTO getPartyDTO(long partyOID) throws DataNotFoundException {
		return partyManagement.getPartyDTOWithObjectOid(partyOID);
	}

	public RaiseGuiRequestResultDTO raiseCreateAgreementRequest(
			ISessionUserProfile sessionUserProfile,
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainPartyDTO maintainPartyDTO) throws ValidationException,
			RequestException {
		Set<RequestKindType> allowableRequestKinds = new HashSet<RequestKindType>();
		if (maintainPartyDTO == null || maintainPartyDTO.getPartyDTO() == null) {
			throw new ValidationException(
					"One can not create an agreement without a party");
		}
		PartyRequestDetails requestDetails = partyMaintenanceController
				.getPartyRequestDetailsForRequest(
						maintainPartyDTO.getPartyDTO(),
						sessionUserProfile,
						maintainPartyDTO.getPartyDTObeforeImage(),
						new RequestKindType[] {
								RequestKindType.MaintainPartyDetails,
								RequestKindType.MaintainOrganisationKnownAsName,
								RequestKindType.MaintainPartyWithApproval,
								RequestKindType.MaintainContactDetails,
								RequestKindType.MaintainSecureContactDetails,
								RequestKindType.MaintainPaymentDetails }, true,
						maintainAgreementDTO.getAgreementKindType());
		if (requestDetails.isObjectModified()) {
			allowableRequestKinds.addAll(Arrays.asList(requestDetails
					.getRequestKindsToRaise()));
		}
		if (isMaintainMedicalAidRequestAllowedForAddAgreement(
				maintainPartyDTO.getMedicalAidDetailDTO(),
				maintainPartyDTO.getMedicalAidDetailDTOBeforeImage())) {
			allowableRequestKinds
					.add(RequestKindType.MaintainMedicalAidDetails);
		}
		allowableRequestKinds.add(RequestKindType.CreateAgreement);
		allowableRequestKinds.add(RequestKindType.MaintainAgreementCodes);
		allowableRequestKinds.add(RequestKindType.MaintainDistributionDetails);
		// SSM2707 ADDED for Hierarchy FR3.5 FAIS details SWETA MENON Begin
		if (isMaintainFAISDetailsRequestAllowedForAddAgreement(maintainAgreementDTO
				.getAgreementDTO())) {
			allowableRequestKinds.add(RequestKindType.MaintainFAISLicense);
		}
		// allowableRequestKinds.add(RequestKindType.MaintainFAISLicense);
		// SSM2707 ADDED for Hierarchy FR3.5 FAIS details SWETA MENON Begin
		allowableRequestKinds.add(RequestKindType.ActivateAgreement);

		// add hierarchy requests kinds
		MaintainAgreementDTO dummy = new MaintainAgreementDTO();
		AgreementDTO agmtDummy = new AgreementDTO();
		agmtDummy
				.setCurrentAndFutureAgreementRoles(new ArrayList<AgreementRoleDTO>(
						0));
		agmtDummy
				.setCurrentAndFutureHomeRoles(new ArrayList<AgreementHomeRoleDTO>(
						0));
		agmtDummy
				.setAssociatedAgreementDetailsList(new ArrayList<AssociatedAgreementDetailsDTO>());
		dummy.setAgreementDTO(agmtDummy);

		if (isAgreementHomeRequestAllowed(maintainAgreementDTO, dummy)) {
			allowableRequestKinds.add(RequestKindType.MaintainAgreementHome);
		}
		if (isMaintainProvidentFundDetailAllowed(maintainAgreementDTO, dummy)) {
			allowableRequestKinds
					.add(RequestKindType.MaintainProvidentFundOptions);
		}
		if (isBranchTransferRequestAllowed(maintainAgreementDTO, dummy)) {
			allowableRequestKinds.add(RequestKindType.BranchTransfer);
		}
		if (isAgreementHierarchyRequestAllowed(maintainAgreementDTO, dummy)) {
			allowableRequestKinds
					.add(RequestKindType.MaintainAgreementHierarchy);
		}
		if (isAgreementServicingRelationshipsRequestAllowed(
				maintainAgreementDTO, dummy)) {
			allowableRequestKinds
					.add(RequestKindType.MaintainAgreementServicingRelationships);
		}
		if (isMaintainAssociatedAgreementRequestAllowed(maintainAgreementDTO,
				dummy)) {
			allowableRequestKinds
					.add(RequestKindType.MaintainAssociatedAgreements);
		}

		// For Differential pricing-08/10/10
		if (maintainAgreementDTO.getScreenMappings().getAQCDetails() != 0) {
			if (isMaintainAdvisorQualityCodeRequestAllowedForAddAgreement(maintainAgreementDTO)) {
				allowableRequestKinds
						.add(RequestKindType.MaintainAdvisorQualityCode);
			}
		}

		// For Fit and Proper II -13/06/11
		if (maintainAgreementDTO.getScreenMappings().getFAISDetails() != 0) {
			if (isMaintainAgreementSupervisors(maintainAgreementDTO, dummy)) {
				allowableRequestKinds
						.add(RequestKindType.MaintainAgreementSupervisors);
			}
		}
		
		setModifiedProperties(maintainAgreementDTO, null);
		maintainAgreementDTO.setLoggedInPartyId(sessionUserProfile
				.getPartyOid());
		CreateAgreementRequestConfigurationDTO createAgreementDTO = new CreateAgreementRequestConfigurationDTO(
				maintainAgreementDTO, maintainPartyDTO);
		try {
			boolean firstAgreement = maintainPartyDTO.getPartyDTO().getOid() == 0;
			ApplicationContext applicationContext = new ApplicationContext();
			applicationContext.setUserid("" + sessionUserProfile.getPartyOid());
			GuiRequestKindType guiRequestKindType = firstAgreement// IF THIS IS
																	// A NEW
																	// PARTY
			// THEN RAISE CREATE WITH MAINTAIN PARTY BEFORE CREATE AGREEMENT
			? GuiRequestKindType.CreateAgreement
					// ELSE RAISE CREATE WITH MAINTAIN PARTY AFTER CREATE
					// AGREEMENT
					: GuiRequestKindType.CreateAgreementWithMaintainParty;
			/**
			 * Raise the request
			 */
			RaiseGuiRequestResultDTO request = guiRequestManager
					.raiseGuiRequest(
							applicationContext,
							sessionUserProfile,
							null,
							(maintainPartyDTO.getPartyDTO() != null && maintainPartyDTO
									.getPartyDTO().getOid() > 0) ? maintainPartyDTO
									.getPartyDTO().getOid() : null,
							guiRequestKindType, allowableRequestKinds
									.toArray(new RequestKindType[0]),
							createAgreementDTO, null);
			return request;
		} catch (RequestConfigurationException e) {
			throw new CommunicationException(e.getMessage(), e);
		}
	}

	/**
	 * Raise a new maintain agreement GUI request.
	 * 
	 * @param sessionUserProfile
	 *            web session user profile
	 * @param partyOid
	 *            id of the party that the agreement is for
	 * @param maintainAgreementDTO
	 *            the current agreement DTO
	 * @param previousMaintainAgreementDTO
	 *            the previous agreement DTO
	 * @return
	 * @throws ValidationException
	 */
	public RaiseGuiRequestResultDTO raiseMaintainAgreementRequest(
			ISessionUserProfile sessionUserProfile, Long partyOid,
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO,
			RequestKindType[] requests) throws ValidationException,
			DataNotFoundException, RequestException {

		/**
		 * Synchronise all deferred loads from current image to before image
		 */
		syncDeferredLoading(maintainAgreementDTO, previousMaintainAgreementDTO);

		maintainAgreementDTO = assessMaintainPrimaryAgreement(maintainAgreementDTO);

		/**
		 * Get allowable request kinds for GUI request
		 */
		Set<RequestKindType> allowableRequestKinds = getAllowableRequestsForMaintainAgreement(
				maintainAgreementDTO, previousMaintainAgreementDTO);
		if (requests != null) {
			/**
			 * Only retain request kinds that were specified
			 */
			allowableRequestKinds.retainAll(Arrays.asList(requests));
		}
		if (allowableRequestKinds == null || allowableRequestKinds.size() == 0) {
			throw new ValidationException(
					"Please only click save if you have changed something otherwise click cancel");
		}

		try {
			ApplicationContext applicationContext = new ApplicationContext();
			applicationContext.setUserid("" + sessionUserProfile.getPartyOid());
			maintainAgreementDTO.setLoggedInPartyId(sessionUserProfile
					.getPartyOid());
			//Inside sets modified data
			setupMaintainAgreementDTO(maintainAgreementDTO,
					previousMaintainAgreementDTO);
			// SSM2707 Hierarchy FR3.4 FAIS Details SWETA MENON
			/*
			 * Check to see if the changes made during maintenance require any
			 * informational messages to be displayed.
			 */
			checkForInfoMessages(maintainAgreementDTO,
					previousMaintainAgreementDTO);
			// If only KROLLCHECKDONE property is maintained doesn't require authorisation
			boolean executeRequest=false;
			List modifiedProperies=maintainAgreementDTO.getModifiedProperties();
			if(modifiedProperies!=null && modifiedProperies.size()==1){
				PropertyDTO propertyDTO=(PropertyDTO)maintainAgreementDTO.getModifiedProperties().get(0);
				if(propertyDTO.getPropertyKind().getDescription().equals(PropertyKindEnumeration.KROLLCHECKDONE.getDescription()) && 
						((allowableRequestKinds.size() == 1) && allowableRequestKinds.iterator().next().equals(RequestKindType.MaintainIntermediaryAgreement)) ){
					maintainAgreementDTO.setOnlyKrollCheckChanged(true);
				}
			}
			/**
			 * Raise GUI request
			 */
			RaiseGuiRequestResultDTO request = guiRequestManager
					.raiseGuiRequest(applicationContext, sessionUserProfile,
							maintainAgreementDTO.getAgreementDTO().getId(),
							partyOid, GuiRequestKindType.MaintainAgreement,
							allowableRequestKinds
									.toArray(new RequestKindType[0]),
							new MaintainAgreementRequestConfigurationDTO(
									maintainAgreementDTO),
							new MaintainAgreementRequestConfigurationDTO(
									previousMaintainAgreementDTO));
			return request;
		} catch (RequestConfigurationException e) {
			throw new CommunicationException(e.getMessage(), e);
		} catch (RequestException e) {
			if (e.getCause() instanceof LogicExecutionValidationException) {
				throw new ValidationException(
						((LogicExecutionException) e.getCause()).getMessage());
			} else {
				throw e;
			}
		}
	}

	private void syncDeferredLoading(MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO)
			throws CommunicationException, DataNotFoundException {
		// RequestKindType[] requestKindTypes =
		// maintainAgreementDTO.getAgreementDTO().getDeferredLoadingCompleted().toArray(
		// new RequestKindType[0]);
		// loadDeferredDataForRequest(previousMaintainAgreementDTO.getAgreementDTO(),
		// null, requestKindTypes);
	}

	/**
	 * Final setup of the maintain agreement DTO object prior to raising any
	 * requests
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 */
	private void setupMaintainAgreementDTO(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		/**
		 * Update the agreement codes for property store, by zeroing any fields
		 * in a compatible way for the properties if they have been zeroed in
		 * the GUI
		 */
		if (maintainAgreementDTO != null
				&& maintainAgreementDTO.getAgreementDTO() != null
				&& maintainAgreementDTO.getAgreementDTO().getAssociatedCodes() != null) {
			AgreementCodesDTO current = maintainAgreementDTO.getAgreementDTO()
					.getAssociatedCodes();
			AgreementCodesDTO previous = previousMaintainAgreementDTO != null
					&& previousMaintainAgreementDTO.getAgreementDTO() != null
					&& previousMaintainAgreementDTO.getAgreementDTO()
							.getAssociatedCodes() != null ? previousMaintainAgreementDTO
					.getAgreementDTO().getAssociatedCodes() : null;
			current.updateValuesForPropertyStore(previous);
		}
		// if (maintainAgreementDTO!=null &&
		// maintainAgreementDTO.getAgreementDTO()!=null &&
		// maintainAgreementDTO.getAgreementDTO().getProvidentFundDetail()!=null)
		// {
		// ProvidentFundDetailDTO current =
		// maintainAgreementDTO.getAgreementDTO().getProvidentFundDetail();
		// ProvidentFundDetailDTO previous =
		// previousMaintainAgreementDTO!=null &&
		// previousMaintainAgreementDTO.getAgreementDTO()!=null &&
		// previousMaintainAgreementDTO.getAgreementDTO().getProvidentFundDetail()!=null
		// ?previousMaintainAgreementDTO.getAgreementDTO().getProvidentFundDetail()
		// :null;
		// current.updateValuesForPropertyStore(previous);
		// }

		/**
		 * Set modified properties after updating agreement codes, as the
		 * modified properties need to reflect these changes
		 */
		setModifiedProperties(maintainAgreementDTO,
				previousMaintainAgreementDTO);
		setModifiedFixedDeductions(maintainAgreementDTO,
				previousMaintainAgreementDTO);
		setModifiedFixedEarnings(maintainAgreementDTO,
				previousMaintainAgreementDTO);
		/**
		 * Set previous pays to details on maintain dto
		 */
		if (previousMaintainAgreementDTO != null
				&& previousMaintainAgreementDTO.getAgreementDTO() != null
				&& previousMaintainAgreementDTO.getAgreementDTO()
						.getPaymentDetails() != null) {
			maintainAgreementDTO
					.setPreviousPayToType(previousMaintainAgreementDTO
							.getAgreementDTO().getPaymentDetails().getPayto());
		}

	}

	/**
	 * Set the modified fixed deductions on the MaintainAgreementDTO instance
	 * object, which will be used for the behaviour logic. All fixed deductions
	 * not marked with the modified flag will be ignored by the behaviour logic.
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 */
	protected void setModifiedFixedDeductions(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO().getFixedDeductions() == null) {
			return;
		}
		List<FixedDeductionDTO> modifiedFixedDeductions = new ArrayList<FixedDeductionDTO>();
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getFixedDeductions() == null) {
			modifiedFixedDeductions.addAll(maintainAgreementDTO
					.getAgreementDTO().getFixedDeductions());
			return;
		}
		modifiedFixedDeductions.addAll(maintainAgreementDTO.getAgreementDTO()
				.getFixedDeductions());
		modifiedFixedDeductions.removeAll(previousMaintainAgreementDTO
				.getAgreementDTO().getFixedDeductions());
		for (FixedDeductionDTO modified : modifiedFixedDeductions) {
			modified.setModified(true);
		}
	}

	/**
	 * Set the modified fixed earnings on the MaintainAgreementDTO instance
	 * object, which will be used for the behaviour logic. All fixed earnings
	 * not marked with the modified flag will be ignored by the behaviour logic.
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 */
	protected void setModifiedFixedEarnings(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO().getFixedEarnings() == null) {
			return;
		}
		List<FixedEarningDTO> modifiedFixedEarnings = new ArrayList<FixedEarningDTO>();
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getFixedEarnings() == null) {
			modifiedFixedEarnings.addAll(maintainAgreementDTO.getAgreementDTO()
					.getFixedEarnings());
			return;
		}
		modifiedFixedEarnings.addAll(maintainAgreementDTO.getAgreementDTO()
				.getFixedEarnings());
		modifiedFixedEarnings.removeAll(previousMaintainAgreementDTO
				.getAgreementDTO().getFixedEarnings());
		for (FixedEarningDTO modified : modifiedFixedEarnings) {
			modified.setModified(true);
		}
	}

	/**
	 * Raise a new terminate agreement GUI request.
	 * 
	 * @param sessionUserProfile
	 *            web session user profile
	 * @param partyOid
	 *            id of the party that the agreement is for
	 * @param maintainAgreementDTO
	 *            the current agreement DTO
	 * @param previousMaintainAgreementDTO
	 *            the previous agreement DTO
	 * @return
	 */
	public RaiseGuiRequestResultDTO raiseTerminateAgreementRequest(
			ISessionUserProfile sessionUserProfile, Long partyOid,
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO)
			throws RequestException {
		/**
		 * Get allowable request kinds for GUI request
		 */
		Set<RequestKindType> allowableRequestKinds = getAllowableRequestsForTerminateAgreement(
				maintainAgreementDTO, previousMaintainAgreementDTO);
		try {
			ApplicationContext applicationContext = new ApplicationContext();
			applicationContext.setUserid("" + sessionUserProfile.getPartyOid());
			setupMaintainAgreementDTO(maintainAgreementDTO,
					previousMaintainAgreementDTO);
			/**
			 * Raise GUI request
			 */
			RaiseGuiRequestResultDTO request = guiRequestManager
					.raiseGuiRequest(applicationContext, sessionUserProfile,
							maintainAgreementDTO.getAgreementDTO().getId(),
							partyOid, GuiRequestKindType.TerminateAgreement,
							allowableRequestKinds
									.toArray(new RequestKindType[0]),
							new TerminateAgreementRequestConfiguration(
									maintainAgreementDTO),
							new TerminateAgreementRequestConfiguration(
									previousMaintainAgreementDTO));
			return request;
		} catch (RequestConfigurationException e) {
			throw new CommunicationException(e.getMessage(), e);
		}
	}

	private void setModifiedProperties(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		List<PropertyDTO> list = getModifiedProperties(maintainAgreementDTO,
				previousMaintainAgreementDTO);
		maintainAgreementDTO.setModifiedProperties(list);
	}

	/**
	 * Compares the previous {@link MaintainAgreementDTO} to the current
	 * {@link MaintainAgreementDTO} and returns all converted
	 * {@link PropertyDTO} or {@link TemporalPropertyDTO} objects from the
	 * {@link AgreementDTO} that have been modified/newly created.
	 * 
	 * This allows only the modified properties to be used in the behaviour
	 * logic when setting agreement properties, to avoid setting properties
	 * uneccessarily.
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	@SuppressWarnings("unchecked")
	private List<PropertyDTO> getModifiedProperties(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null) {
			return null;
		}
		List<PropertyDTO> ret = new ArrayList<PropertyDTO>();
		List<PropertySpecDTO> propertySpecs = getPropertySpecsForAgreementSpecification(maintainAgreementDTO
				.getAgreementDTO().getSpecificationId());
		for (PropertySpecDTO propertySpec : propertySpecs) {
			PropertyDTO currentProperty = agreementPropertyConverter
					.getPropertyOfKindFromAgreementDTO(
							propertySpec.getPropertyKind(),
							maintainAgreementDTO.getAgreementDTO());
			if (currentProperty == null) {
				/**
				 * No property of kind found in the agreementDTO, skip
				 */
				continue;
			}
			PropertyDTO previousProperty = null;
			if (previousMaintainAgreementDTO != null
					&& previousMaintainAgreementDTO.getAgreementDTO() != null) {
				previousProperty = agreementPropertyConverter
						.getPropertyOfKindFromAgreementDTO(
								propertySpec.getPropertyKind(),
								previousMaintainAgreementDTO.getAgreementDTO());
			}
			if (currentProperty instanceof TemporalPropertyDTO) {
				if (!((TemporalPropertyDTO) currentProperty)
						.equals(previousProperty)) {
					ret.add(currentProperty);
				}
			} else if (!currentProperty.equals(previousProperty)) {
				ret.add(currentProperty);
			}
		}
		return ret;
	}

	/**
	 * Determine the requests that should be raised from changes that have been
	 * made by comparing the before and after images.
	 * 
	 * This will delegate comparison for each request to sub methods.
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	private Set<RequestKindType> getAllowableRequestsForMaintainAgreement(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		Set<RequestKindType> ret = new HashSet<RequestKindType>();
		if (maintainAgreementDTO == null) {
			return ret;
		}

		/**
		 * Determine based on the changes in the DTOs which requests should be
		 * raised, if any
		 */
		if (previousMaintainAgreementDTO != null) {
			/**
			 * Check MaintainIntermediaryAgreement
			 */
			if (isMaintainIntermediaryAgreementRequestAllowed(
					maintainAgreementDTO, previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainIntermediaryAgreement);
			}
			if (isMaintainPaysToRequestAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainPaysTo);
			}
			if (isMaintainDistributionDetailsRequestAllowed(
					maintainAgreementDTO, previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainDistributionDetails);
			}
			if (isPoolAccountRequestAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainPoolAccount);
			}
			if (isMaintainAgreementCodesRequestAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainAgreementCodes);
			}
			if (isMaintainAssociatedAgreementRequestAllowed(
					maintainAgreementDTO, previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainAssociatedAgreements);
			}
			if (isMaintainPaymentSchedulerAgreementRequestAllowed(
					maintainAgreementDTO, previousMaintainAgreementDTO)) {

				if (isPaymentSchedulerRequestWithApprovalTobeRaised(
						maintainAgreementDTO, previousMaintainAgreementDTO)) {
					ret.add(RequestKindType.MaintainPaymentSchedulerDetailsWithApproval);
				} else
					ret.add(RequestKindType.MaintainPaymentSchedulerDetails);
			}

			if (isMaintainFAISRequestAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainFAISLicense);
			}

			if (isMaintainFAISStatusRequestAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainFAISLicenseStatus);
			}

			if (isMaintainFixedDeductionsAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainFixedDeductionDetails);
			}

			if (isMaintainFixedEarningsAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainFixedEarningDetails);
			}

			if (isAgreementHomeRequestAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainAgreementHome);
			}

			if (isBranchTransferRequestAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.BranchTransfer);
			}

			if (isAgreementServicingRelationshipsRequestAllowed(
					maintainAgreementDTO, previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainAgreementServicingRelationships);
			}

			if (isAgreementHierarchyRequestAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainAgreementHierarchy);
			}

			if (isMaintainAdvisorQualityCodeRequestAllowed(
					maintainAgreementDTO, previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainAdvisorQualityCode);
			}
			if (isMaintainMaxUpfronCommPercentRequestAllowed(maintainAgreementDTO, previousMaintainAgreementDTO)){
				ret.add(RequestKindType.MaintainMaxUpfrontCommPercent);
			}
			if (isMaintainAgreementSupervisors(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainAgreementSupervisors);
			}
			if (isMaintainBusinessStakeholder(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainAgreementHierarchy);
			}
			if (isMaintainIncetivesAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainIncentiveDetails);
			}

			if (isMaintainProvidentFundDetailAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainProvidentFundOptions);
			}
			// Added for LCB Accreditation-Pks-13/12/12
			if (isMaintainCorpCommissionAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainCorpCommIndicator);
			}

			// SSM2707 Added for Hierarchy FR3.5 Primary Agreement SWETA MENON
			if (isMaintainPrimaryAgreementRequestAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainPrimaryAgreement);
			}
			// Market Integration SWETA MENON 3rd March 2016
			if (isCreateServicingPanelRequestAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.CreateServicingPanel);
			}
			
			// SSM2707 Sweta Menon Agency Pool 10/10/2017 Begin
			if (isSetOverrideIntoPoolRateRequestAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.SetOverrideIntoPoolRate);
			}
			
			if (isAdhocAgencyPoolDrawRequestAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.AdhocAgencyPoolDraw);
			}
			if (isStopAgencyPoolTransferRequestAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.StopAgencyPoolTransfer);
			}
			if (isCloseAgencyPoolRequestAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.CloseAgencyPool);
			}
			if (isMaintainProvidentBeneficiariesRequestAllowed(maintainAgreementDTO, 
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainProvidentFundBeneficiaries);
			}
		}
		return ret;
	}

	private boolean isMaintainBusinessStakeholder(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		List<AgreementRoleDTO> otherRoles = new ArrayList<AgreementRoleDTO>(
				maintainAgreementDTO.getAgreementDTO()
						.getCurrentAndFutureSupervisorRoles());
		for (AgreementRoleDTO role : maintainAgreementDTO.getAgreementDTO()
				.getCurrentAndFutureSupervisorRoles()) {
			if (role.getKind() == RoleKindType.ISSERVICEDBY.getKind()
					|| role.getKind() == RoleKindType.SUPERVISEDBY.getKind()) {
				otherRoles.remove(role);
			}
		}
		List<AgreementRoleDTO> otherRolesOld = new ArrayList<AgreementRoleDTO>();
		if (previousMaintainAgreementDTO.getAgreementDTO()
				.getCurrentAndFutureSupervisorRoles() != null) {
			otherRolesOld = new ArrayList<AgreementRoleDTO>(
					previousMaintainAgreementDTO.getAgreementDTO()
							.getCurrentAndFutureSupervisorRoles());
			for (AgreementRoleDTO role : previousMaintainAgreementDTO
					.getAgreementDTO().getCurrentAndFutureSupervisorRoles()) {
				if (role.getKind() == RoleKindType.ISSERVICEDBY.getKind()
						|| role.getKind() == RoleKindType.SUPERVISEDBY
								.getKind()) {
					otherRolesOld.remove(role);
				}
			}
		}
		return (ComparatorUtil.compareObjects(otherRoles, otherRolesOld, true)
				.size() != 0);
	}

	/**
	 * Determine the requests that should be raised from changes that have been
	 * made by comparing the before and after images.
	 * 
	 * This will delegate comparison for each request to sub methods.
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	private Set<RequestKindType> getAllowableRequestsForTerminateAgreement(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		Set<RequestKindType> ret = new HashSet<RequestKindType>();

		if (maintainAgreementDTO == null) {
			return ret;
		}
		/**
		 * Terminate agreement always required
		 */
		ret.add(RequestKindType.TerminateIntermediaryAgreement);
		/**
		 * Determine based on the changes in the DTOs which requests should be
		 * raised, if any
		 */
		if (previousMaintainAgreementDTO != null) {
			if (isMaintainDistributionDetailsRequestAllowed(
					maintainAgreementDTO, previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainDistributionDetails);
			}
			if (isPoolAccountRequestAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainPoolAccount);
			}
			if (isMaintainFixedDeductionsAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainFixedDeductionDetails);
			}

			if (isMaintainFixedEarningsAllowed(maintainAgreementDTO,
					previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainFixedEarningDetails);
			}

			if (isMaintainPaymentSchedulerAgreementRequestAllowed(
					maintainAgreementDTO, previousMaintainAgreementDTO)) {
				ret.add(RequestKindType.MaintainPaymentSchedulerDetailsWithApproval);
			}

		}
		return ret;
	}

	private boolean isMaintainFixedDeductionsAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO().getFixedDeductions() == null) {
			return false;
		}
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getFixedDeductions() == null) {
			return true;
		}
		return !maintainAgreementDTO
				.getAgreementDTO()
				.getFixedDeductions()
				.equals(previousMaintainAgreementDTO.getAgreementDTO()
						.getFixedDeductions());
	}

	private boolean isMaintainFixedEarningsAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO().getFixedEarnings() == null) {
			return false;
		}
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getFixedEarnings() == null) {
			return true;
		}
		return !maintainAgreementDTO
				.getAgreementDTO()
				.getFixedEarnings()
				.equals(previousMaintainAgreementDTO.getAgreementDTO()
						.getFixedEarnings());
	}

	private boolean isPaymentSchedulerRequestWithApprovalTobeRaised(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		boolean doNotPayIndicatorChanged = false;
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO()
						.getPaymentSchedulerDTO() == null) {
			return false;
		}
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getPaymentSchedulerDTO() == null) {
			return false;
		}
		PaymentSchedulerDTO currentDto = maintainAgreementDTO.getAgreementDTO()
				.getPaymentSchedulerDTO();
		PaymentSchedulerDTO previousDto = previousMaintainAgreementDTO
				.getAgreementDTO().getPaymentSchedulerDTO();
		if (currentDto.isDoNotPay() != previousDto.isDoNotPay()) {
			doNotPayIndicatorChanged = true;
		}
		// 07/07/10-Changed for bug- Authorisation must only be requested when
		// 'Do not Pay' is unchecked
		// 18/08/2010- Fixed-Only if DO Not pay has changed and is unchecked.

		return (doNotPayIndicatorChanged && !currentDto.isDoNotPay());

	}

	/**
	 * Will return true if the MaintainAgreementHome Request is allowe to be
	 * raised<br/>
	 * Will compare the list of objects and see if there are any changes
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	private boolean isAgreementHomeRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		// use compare util to determin if request must be raised
		// get the list of home roles and compare
		// boolean consCodeChanged =
		// (ComparatorUtil.compareObjects(maintainAgreementDTO.getAgreementDTO().getConsultantCode(),
		// previousMaintainAgreementDTO.getAgreementDTO().getConsultantCode(),true).size()
		// != 0);
		// boolean homeRolesChanged =
		// (ComparatorUtil.compareObjects(maintainAgreementDTO.getAgreementDTO().getCurrentAndFutureHomeRoles(),
		// previousMaintainAgreementDTO.getAgreementDTO().getCurrentAndFutureHomeRoles(),
		// true).size() != 0);
		// return (!consCodeChanged && homeRolesChanged);
		List<ObjectComparisonDifferences> diffs = ComparatorUtil
				.compareObjects(maintainAgreementDTO.getAgreementDTO()
						.getCurrentAndFutureHomeRoles(),
						previousMaintainAgreementDTO.getAgreementDTO()
								.getCurrentAndFutureHomeRoles());
		if (diffs.size() == 0) {
			return false;
		}
		return !isBranchTransferRequestAllowed(maintainAgreementDTO,
				previousMaintainAgreementDTO);
	}

	/**
	 * Will return true if the MaintainAgreementHome Request is allowe to be
	 * raised<br/>
	 * Will compare the list of objects and see if there are any changes
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	private boolean isBranchTransferRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		// does not matter if the home roles never changed, we still raise this
		// request for the 13 digit code
		List<ObjectComparisonDifferences> diffs = ComparatorUtil
				.compareObjects(maintainAgreementDTO.getAgreementDTO()
						.getCurrentAndFutureHomeRoles(),
						previousMaintainAgreementDTO.getAgreementDTO()
								.getCurrentAndFutureHomeRoles());
		// only branch transfer requests will be done, home changes can not be
		// done without a thirteen digit code change
		// return (diffs.size() != 0);
		boolean newRoleAdded = false;
		for (AgreementHomeRoleDTO homeRole : maintainAgreementDTO
				.getAgreementDTO().getCurrentAndFutureHomeRoles()) {
			if (homeRole.getRoleID() <= 0) {
				newRoleAdded = true;
			}
		}

		if (diffs.size() == 0) {
			return false;
		} else if (maintainAgreementDTO.getAgreementDTO()
				.getCurrentAndFutureHomeRoles().size() > 0
				&& ((previousMaintainAgreementDTO.getAgreementDTO()
						.getCurrentAndFutureHomeRoles() != null) ? previousMaintainAgreementDTO
						.getAgreementDTO().getCurrentAndFutureHomeRoles()
						.size() == 0
						: true)) {
			// if adding a new home role then a cons code is required
			return true;
		} else if (newRoleAdded
				&& maintainAgreementDTO.getAgreementDTO()
						.getCurrentAndFutureHomeRoles().size() > 1) {
			// we will just check if it is the same cons code used for the
			// future, if so then a home change is raised
			String currentCode = maintainAgreementDTO.getAgreementDTO()
					.getCurrentAndFutureHomeRoles().get(0).getConsultantCode();
			for (AgreementHomeRoleDTO homeRole : maintainAgreementDTO
					.getAgreementDTO().getCurrentAndFutureHomeRoles()) {
				if (!homeRole.getConsultantCode().equalsIgnoreCase(currentCode)) {
					return true;
				}
			}
			// the consultant code has to be added if a future dated role is
			// added
			return false;
		}
		// loop through changes and see if one is cons code
		for (ObjectComparisonDifferences diff : diffs) {
			if (diff.getFieldName().equalsIgnoreCase("consultantCode")) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Will return true if the MaintainAgreementServicingRelationships Request
	 * is allowe to be raised<br/>
	 * Will compare the list of objects and see if there are any changes
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	private boolean isAgreementServicingRelationshipsRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		// use compare util to determin if request must be raised
		// get the list of home roles and compare
		List<AgreementRoleDTO> servicingRoles = new ArrayList<AgreementRoleDTO>();
		for (AgreementRoleDTO role : maintainAgreementDTO.getAgreementDTO()
				.getCurrentAndFutureAgreementRoles()) {
			if (role.getKind() == RoleKindType.ISSERVICEDBY.getKind()) {
				servicingRoles.add(role);
			}
		}
		List<AgreementRoleDTO> servicingRolesOld = new ArrayList<AgreementRoleDTO>();
		for (AgreementRoleDTO role : previousMaintainAgreementDTO
				.getAgreementDTO().getCurrentAndFutureAgreementRoles()) {
			if (role.getKind() == RoleKindType.ISSERVICEDBY.getKind()) {
				servicingRolesOld.add(role);
			}
		}
		return (ComparatorUtil.compareObjects(servicingRoles,
				servicingRolesOld, true).size() != 0);
	}

	/**
	 * Will return true if the AgreementHierarchy Request is allowe to be raised<br/>
	 * Will compare the list of objects and see if there are any changes
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	private boolean isAgreementHierarchyRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		// use compare util to determin if request must be raised
		// get the list of home roles and compare
		List<AgreementRoleDTO> otherRoles = new ArrayList<AgreementRoleDTO>(
				maintainAgreementDTO.getAgreementDTO()
						.getCurrentAndFutureAgreementRoles());
		for (AgreementRoleDTO role : maintainAgreementDTO.getAgreementDTO()
				.getCurrentAndFutureAgreementRoles()) {
			if (role.getKind() == RoleKindType.ISSERVICEDBY.getKind()) {
				otherRoles.remove(role);
			}
		}

		List<AgreementRoleDTO> otherRolesOld = new ArrayList<AgreementRoleDTO>(
				previousMaintainAgreementDTO.getAgreementDTO()
						.getCurrentAndFutureAgreementRoles());
		for (AgreementRoleDTO role : previousMaintainAgreementDTO
				.getAgreementDTO().getCurrentAndFutureAgreementRoles()) {
			if (role.getKind() == RoleKindType.ISSERVICEDBY.getKind()) {
				otherRolesOld.remove(role);
			}
		}
		return (ComparatorUtil.compareObjects(otherRoles, otherRolesOld, true)
				.size() != 0);
	}

	/**
	 * check if a provident fund request is allowed to be raised
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	private boolean isMaintainProvidentFundDetailAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO()
						.getProvidentFundDetail() == null) {
			return false;
		}
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getProvidentFundDetail() == null) {
			return true;
		}
		return (ComparatorUtil
				.compareObjects(
						maintainAgreementDTO.getAgreementDTO()
								.getProvidentFundDetail(),
						previousMaintainAgreementDTO.getAgreementDTO()
								.getProvidentFundDetail(), true).size() != 0);
	}

	/**
	 * check if the Maintain Corporate Commission Request is allowed to be
	 * raised
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	private boolean isMaintainCorpCommissionAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO()
						.getHoldCorpCommission() == null) {
			return false;
		}
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getHoldCorpCommission() == null) {
			return true;
		}

		Boolean currHoldCorpCommValue = maintainAgreementDTO.getAgreementDTO()
				.getHoldCorpCommission().getValue() == null ? false
				: maintainAgreementDTO.getAgreementDTO()
						.getHoldCorpCommission().getValue();
		Boolean prevHoldCorpCommValue = previousMaintainAgreementDTO
				.getAgreementDTO().getHoldCorpCommission().getValue() == null ? false
				: previousMaintainAgreementDTO.getAgreementDTO()
						.getHoldCorpCommission().getValue();

		return (!currHoldCorpCommValue.equals(prevHoldCorpCommValue));

	}

	/**
	 * check if an incetive request is allowed to be raised
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	private boolean isMaintainIncetivesAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO()
						.getCurrentAndFutureIncentives() == null) {
			return false;
		}
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getCurrentAndFutureIncentives() == null) {
			return true;
		}
		return (ComparatorUtil.compareObjects(
				maintainAgreementDTO.getAgreementDTO()
						.getCurrentAndFutureIncentives(),
				previousMaintainAgreementDTO.getAgreementDTO()
						.getCurrentAndFutureIncentives(), true).size() != 0);
	}

	private boolean isMaintainFAISRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO().getFaisLicense() == null) {
			return false;
		}
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getFaisLicense() == null) {
			return true;
		}
		List<ObjectComparisonDifferences> diffs = ComparatorUtil
				.compareObjects(maintainAgreementDTO.getAgreementDTO()
						.getFaisLicense(), previousMaintainAgreementDTO
						.getAgreementDTO().getFaisLicense(), true);
		if (diffs.size() > 1) {
			return true;
		} else if (diffs.size() == 1
				&& maintainAgreementDTO.getAgreementDTO().getFaisLicense()
						.getFaisLicenseStatus() == previousMaintainAgreementDTO
						.getAgreementDTO().getFaisLicense()
						.getFaisLicenseStatus()) {
			return true;
		}
		return false;
	}

	private boolean isMaintainFAISStatusRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO().getId() <= 0
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getFaisLicense() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getFaisLicense().getOid() <= 0) {
			// not allowing a status change on add agreement
			return false;
		}
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO().getFaisLicense() == null) {
			return false;
		}
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getFaisLicense() == null) {
			return true;
		}
		return maintainAgreementDTO.getAgreementDTO().getFaisLicense()
				.getFaisLicenseStatus() != previousMaintainAgreementDTO
				.getAgreementDTO().getFaisLicense().getFaisLicenseStatus();
	}

	private boolean isMaintainPaymentSchedulerAgreementRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO()
						.getPaymentSchedulerDTO() == null) {
			return false;
		}

		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getPaymentSchedulerDTO() == null) {
			return true;
		}

		PaymentSchedulerDTO currentDto = maintainAgreementDTO.getAgreementDTO()
				.getPaymentSchedulerDTO();
		PaymentSchedulerDTO previousDto = previousMaintainAgreementDTO
				.getAgreementDTO().getPaymentSchedulerDTO();

		return !currentDto.equals(previousDto);
	}

	private boolean isMaintainAssociatedAgreementRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {

		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO()
						.getAssociatedAgreementDetailsList() == null) {
			return false;
		}
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getAssociatedAgreementDetailsList() == null) {
			return true;
		}
		List<AssociatedAgreementDetailsDTO> currentDtos = maintainAgreementDTO
				.getAgreementDTO().getAssociatedAgreementDetailsList();
		List<AssociatedAgreementDetailsDTO> previousDtos = previousMaintainAgreementDTO
				.getAgreementDTO().getAssociatedAgreementDetailsList();

		return !currentDtos.equals(previousDtos);

	}

	/**
	 * Compare the before and after MaintainAgreementDTO image to determine if
	 * MaintainPaysTo request should be raised
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	private boolean isMaintainPaysToRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO().getPaymentDetails() == null) {
			return false;
		}
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getPaymentDetails() == null) {
			return true;
		}
		PaysToDTO currentClone = maintainAgreementDTO.getAgreementDTO()
				.getPaymentDetails();
		PaysToDTO previousClone = previousMaintainAgreementDTO
				.getAgreementDTO().getPaymentDetails();
		return !currentClone.equals(previousClone);
	}

	// SSM2707 Added for Hierarchy FR3.5 Primary Agreement SWETA MENON Begin
	/**
	 * Compare the before and after MaintainAgreementDTO image to determine if
	 * MaintainPrimaryAgreement request should be raised
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	private boolean isMaintainPrimaryAgreementRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		Boolean currentValue = maintainAgreementDTO.getAgreementDTO()
				.isPrimaryAgreement();
		Boolean previousValue = getPreviousPrimaryAgreementVal(maintainAgreementDTO
				.getAgreementDTO());

		if ((currentValue == null || currentValue.equals(Boolean.FALSE))
				&& (previousValue == null || previousValue
						.equals(Boolean.FALSE))) {
			return false;
		}
		if (!currentValue.equals(previousValue)) {
			return true;
		} else {
			return false;
		}
	}

	private MaintainAgreementDTO assessMaintainPrimaryAgreement(
			MaintainAgreementDTO maintainAgreementDTO)
			throws ValidationException {

		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO().getPartyOid() == null
				|| maintainAgreementDTO.getAgreementDTO().getKind() <= 0) {
			return maintainAgreementDTO;
		}
		Map<Long, Long> primaryAgreementMap = null;
		if (getPrimaryAgreementMap() == null) {
			primaryAgreementMap = getPrimaryAgreementMap(maintainAgreementDTO
					.getAgreementDTO().getPartyOid());
			setPrimaryAgreementMap(primaryAgreementMap);
		}

		/*
		 * Does the current party have a primary agreement in the selected kind?
		 */
		int agreementKind = maintainAgreementDTO.getAgreementDTO().getKind();

		// Get the Primary Agreement Division for the new
		// Agreement kind
		PrimaryAgreementDivisionType divisionType = AgreementKindType
				.getAgreementKindType(agreementKind)
				.getPrimaryAgreementDivisionType();

		/*
		 * Check if the current party has an agreement in the kind type
		 */

		if (primaryAgreementMap != null
				&& primaryAgreementMap.containsKey(Long.valueOf(divisionType
						.getKind()))
				&& (primaryAgreementMap
						.get(Long.valueOf(divisionType.getKind())) != null)) {
			/*
			 * Party contains an agreement in the desired division. Identify if
			 * the Primary agreement is In-force
			 */
			/*
			 * An In-force agreement is one having status Active or [Retired
			 * with status reason Retired Active]
			 */
			Long primaryAgmtNumber = primaryAgreementMap.get(Long
					.valueOf(divisionType.getKind()));
			if (!isAgreementInForce(primaryAgmtNumber, agreementKind)) {
				/*
				 * If the primary agreement in the party-division combination is
				 * outOf-force, set the primaryAgreement boolean to TRUE in the
				 * context AgreementDTO object.
				 */
				maintainAgreementDTO.getAgreementDTO().setPrimaryAgreement(
						Boolean.TRUE);
			}
		} else {
			/*
			 * If the primary agreement map is empty or null, the current
			 * agreement is set as the primary agreement. Set the
			 * primaryAgreement boolean to TRUE in the context AgreementDTO
			 * object
			 */
			maintainAgreementDTO.getAgreementDTO().setPrimaryAgreement(
					Boolean.TRUE);

		}

		PrimaryAgreementDTO primaryAgmDTO = determineContextPartiesPrimaryAgmtSOLOHCatchUP(maintainAgreementDTO
				.getAgreementDTO().getPartyOid().longValue());

		maintainAgreementDTO.getAgreementDTO().setPrimaryAgreementDTO(
				primaryAgmDTO);

		return maintainAgreementDTO;
	}

	/**
	 * Method to access the previous (original) primary agreement indicator
	 * value for the input agreemntDTO.
	 */

	private boolean getPreviousPrimaryAgreementVal(AgreementDTO agreementDTO) {
		Long currentAgmtNumber = null;
		Map<Long, Long> primaryAgmtMap = null;

		// Get the current agreement number
		if (agreementDTO != null && agreementDTO.getId() > 0
				&& agreementDTO.getPartyOid() > 0) {

			try {
				currentAgmtNumber = agreementDTO.getId();
				/*
				 * Obtain the primary agreement map for the corresponding Party
				 * ObjectID
				 */
				Map<Long, Long> primaryAgreementMap = null;
				if (getPrimaryAgreementMap() == null) {
					primaryAgreementMap = getPrimaryAgreementMap(agreementDTO
							.getPartyOid());
					setPrimaryAgreementMap(primaryAgreementMap);
				}
				primaryAgmtMap = getPrimaryAgreementMap(agreementDTO
						.getPartyOid());
			} catch (ValidationException e) {
				SystemException sys = new SystemException(
						"Exception occurred when trying to obtain Primary Agreement details.",
						0, 0);
				sys.initCause(e);
				throw sys;
			}
		} else {
			/*
			 * If the agreement number cannot be obtained, the
			 * isPrimaryAgreement boolean is set to FALSE.
			 */
			return false;
		}

		/*
		 * Validate if the current agreement number is defined as primary for
		 * the party. The primaryAgreementMap is of the constitution-
		 * Key-Kind/division value-AgreementNumber
		 */
		if (primaryAgmtMap != null && primaryAgmtMap.size() > 0) {

			/* Get the list of map values (agreement numbers) */
			Collection<Long> primaryAgmtNumbers = primaryAgmtMap.values();

			if (primaryAgmtNumbers.contains(currentAgmtNumber)) {
				/*
				 * If the current agreement is the primary agreement, set the
				 * primaryAgreement boolean to TRUE in the context AgreementDTO
				 * object.
				 */
				return true;
			} else {
				/*
				 * If the current agreement is not the primary agreement, set
				 * the primaryAgreement boolean to FALSE in the context
				 * AgreementDTO object.
				 */
				return false;
			}

		} else {
			/*
			 * If the primaryAgreementMap is null/Empty, set the
			 * primaryAgreement boolean to FALSE in the context AgreementDTO
			 * object.
			 */
			return false;
		}
	}

	/**
	 * This method is used to set the primary agreement value in the context
	 * agreementDTO object.
	 */
	public AgreementDTO getPrimaryAgreementValForAgreement(
			AgreementDTO agreementDTO) {

		int currentKind = agreementDTO.getKind();
		// Set the current primary agreement to 0.
		setCurrPrimaryAgreementNumber(0);

		if (agreementDTO == null || agreementDTO.getId() <= 0
				|| agreementDTO.getPartyOid() <= 0
				|| agreementDTO.getKind() <= 0) {

			/*
			 * If the agreement number cannot be obtained, the
			 * isPrimaryAgreement boolean is set to FALSE.
			 */
			agreementDTO.setPrimaryAgreement(false);
			agreementDTO.setPrimaryAgreementForced(false);
			return agreementDTO;

		}

		Long currentAgmtNumber = agreementDTO.getId();

		Map<Long, Long> primaryAgreementMap = null;
		// Get the current agreement number
		try {
			/*
			 * Obtain the primary agreement map for the corresponding Party
			 * ObjectID
			 */

			PrimaryAgreementDivisionType currDivisionType = AgreementKindType
					.getAgreementKindType(currentKind)
					.getPrimaryAgreementDivisionType();

			if (getPrimaryAgreementMap() == null) {
				primaryAgreementMap = getPrimaryAgreementMap(agreementDTO
						.getPartyOid());
				setPrimaryAgreementMap(primaryAgreementMap);
			}

			/*
			 * Validate if the current agreement number is defined as primary
			 * for the party. The primaryAgreementMap is of the constitution-
			 * Key-Kind/division value-AgreementNumber
			 */
			if (primaryAgreementMap != null && primaryAgreementMap.size() > 0
					&& primaryAgreementMap.values().contains(currentAgmtNumber)) {
				/*
				 * If the current agreement is the primary agreement, set the
				 * primaryAgreement boolean to TRUE in the context AgreementDTO
				 * object.
				 */
				agreementDTO.setPrimaryAgreement(true);
				agreementDTO.setPrimaryAgreementForced(false);
				return agreementDTO;
			} else if (primaryAgreementMap != null
					&& primaryAgreementMap.size() > 0
					&& primaryAgreementMap.keySet().contains(
							Long.valueOf(currDivisionType.getKind()))) {
				/*
				 * If there is a primary agreement set in the current division,
				 * set the setCurrPrimaryAgreementNumber()
				 */
				setCurrPrimaryAgreementNumber(primaryAgreementMap.get(Long
						.valueOf(currDivisionType.getKind())));
			}

		} catch (ValidationException e) {
			SystemException sys = new SystemException(
					"Exception occurred when trying to obtain Primary Agreement details.",
					0, 0);
			sys.initCause(e);
			throw sys;

		}

		/*
		 * Check if the current party contains agreement other than the current
		 * agreement
		 */

		List<Long> partyAgreementNumbers = entityManager
				.findAllAgreementsLinkedToParty(agreementDTO.getPartyOid());

		List<AgreementStatusAndStatusReasonFLO> partyAgreementFlos = getAgreementsInPartyAndKind(
				partyAgreementNumbers, currentAgmtNumber, currentKind);
		if (partyAgreementFlos == null || partyAgreementFlos.size() <= 0) {
			/*
			 * Set the current agreement as primary by force. Reason: There are
			 * no other agreements in the current kind
			 */
			agreementDTO.setPrimaryAgreement(true);
			agreementDTO.setPrimaryAgreementForced(true);
			return agreementDTO;

		}
		/* Is current agreement in-force */
		boolean isCurrentAgreementInForce = isAgreementInForce(
				currentAgmtNumber, currentKind);

		boolean isOtherAgmtInForce = isAgreementInForce(partyAgreementFlos);

		if (isCurrentAgreementInForce && (!isOtherAgmtInForce)) {
			/*
			 * current Agreement: in-force OtherAgreements: Out of force
			 */

			agreementDTO.setPrimaryAgreement(true);
			agreementDTO.setPrimaryAgreementForced(true);
			return agreementDTO;

		} else if (isCurrentAgreementInForce && isOtherAgmtInForce) {
			/*
			 * current Agreement: in-force OtherAgreements: in-force
			 */
			agreementDTO.setPrimaryAgreement(false);
			agreementDTO.setPrimaryAgreementForced(false);
			return agreementDTO;

		} else if (!isCurrentAgreementInForce && isOtherAgmtInForce) {
			/*
			 * current Agreement: Out of force OtherAgreements: in force
			 */
			agreementDTO.setPrimaryAgreement(false);
			agreementDTO.setPrimaryAgreementForced(true);
			return agreementDTO;
		} else if (!isCurrentAgreementInForce && !isOtherAgmtInForce) {
			/*
			 * current Agreement: Out of force OtherAgreements: Out of force
			 */
			/* Access based on agreement end dates */
			agreementDTO = isPrimaryAgreement(agreementDTO, currentAgmtNumber,
					partyAgreementNumbers);
			return agreementDTO;
		}

		PrimaryAgreementDTO primaryAgmDTO = determineContextPartiesPrimaryAgmtSOLOHCatchUP(agreementDTO
				.getPartyOid());

		agreementDTO.setPrimaryAgreementDTO(primaryAgmDTO);

		return agreementDTO;
	}

	public boolean getPrimaryAgmntValForAddAgreement(
			Map<Long, Long> primaryAgreementMap, int agreementKind,
			long partyOid) {

		// Get the Primary Agreement Division for the new
		// Agreement kind
		PrimaryAgreementDivisionType divisionType = AgreementKindType
				.getAgreementKindType(agreementKind)
				.getPrimaryAgreementDivisionType();

		/*
		 * Check if the current party has an agreement in the kind type
		 */

		if (primaryAgreementMap != null
				&& primaryAgreementMap.containsKey(Long.valueOf(divisionType
						.getKind()))
				&& (primaryAgreementMap
						.get(Long.valueOf(divisionType.getKind())) != null)) {
			/*
			 * Party contains an agreement in the desired division. Identify if
			 * the Primary agreement is In-force
			 */
			/*
			 * An In-force agreement is one having status Active or [Retired
			 * with status reason Retired Active]
			 */
			Long primaryAgmtNumber = primaryAgreementMap.get(Long
					.valueOf(divisionType.getKind()));

			if (isAgreementInForce(primaryAgmtNumber, agreementKind)) {

				/*
				 * If the primary agreement in the party-division combination is
				 * in-force, set the primaryAgreement boolean to FALSE in the
				 * context AgreementDTO object.
				 */
				setCurrPrimaryAgreementNumber(primaryAgmtNumber);
				return false;
			} else {
				/*
				 * If the primary agreement in the party-division combination is
				 * out Of-force, set the primaryAgreement boolean to TRUE in the
				 * context AgreementDTO object.
				 */
				setCurrPrimaryAgreementNumber(primaryAgmtNumber);
				return true;
			}
		} else {
			/* If there are no primary agreements in the current division/kind */

			// Obtain the existing agreement numbers belonging to the current
			// party.
			List<Long> partyAgreementNumbers = entityManager
					.findAllAgreementsLinkedToParty(partyOid);

			List<AgreementStatusAndStatusReasonFLO> partyAgreementFlos = getAgreementsInPartyAndKind(
					partyAgreementNumbers, 0, agreementKind);
			if (partyAgreementFlos == null || partyAgreementFlos.size() <= 0) {
				/*
				 * Set the current agreement as primary by force. Reason: There
				 * are no other agreements in the current kind
				 */
				/*
				 * Set the current primary agreement number to 0 so the warning
				 * message is not displayed in the wizard screen when the
				 * checkbox is checked/unchecked.
				 */
				setCurrPrimaryAgreementNumber(0);
				return true;
			}

			boolean isOtherAgmtInForce = isAgreementInForce(partyAgreementFlos);

			if (!isOtherAgmtInForce) {
				/*
				 * OtherAgreements: Out of force
				 */
				/*
				 * Set the current primary agreement number to 0 so the warning
				 * message is not displayed in the wizard screen when the
				 * checkbox is checked/unchecked.
				 */
				setCurrPrimaryAgreementNumber(0);
				return true;
			} else if (isOtherAgmtInForce) {
				/*
				 * OtherAgreements: in-force
				 */
				/*
				 * Set the current primary agreement number to 0 so the warning
				 * message is not displayed in the wizard screen when the
				 * checkbox is checked/unchecked.
				 */
				setCurrPrimaryAgreementNumber(0);
				return false;
			}
		}
		return false;
	}

	/**
	 * This method is used to set the primary agreement value in the context
	 * agreementDTO object.
	 */
	public boolean isCurrentAgreementPrimary(AgreementDTO agreementDTO) {
		Long currentAgmtNumber = null;
		Map<Long, Long> primaryAgreementMap = null;
		// Get the current agreement number
		if (agreementDTO != null && agreementDTO.getId() > 0
				&& agreementDTO.getPartyOid() > 0) {

			try {
				currentAgmtNumber = agreementDTO.getId();
				/*
				 * Obtain the primary agreement map for the corresponding Party
				 * ObjectID
				 */

				if (getPrimaryAgreementMap() == null) {
					primaryAgreementMap = getPrimaryAgreementMap(agreementDTO
							.getPartyOid());
					setPrimaryAgreementMap(primaryAgreementMap);
				}

			} catch (ValidationException e) {
				SystemException sys = new SystemException(
						"Exception occurred when trying to obtain Primary Agreement details.",
						0, 0);
				sys.initCause(e);
				throw sys;

			}
		} else {
			/*
			 * If the agreement number cannot be obtained, the
			 * isPrimaryAgreement boolean is set to FALSE.
			 */
			return false;
		}

		/*
		 * Validate if the current agreement number is defined as primary for
		 * the party. The primaryAgreementMap is of the constitution-
		 * Key-Kind/division value-AgreementNumber
		 */
		if (primaryAgreementMap != null && primaryAgreementMap.size() > 0) {

			/* Get the list of map values (agreement numbers) */
			Collection<Long> primaryAgmtNumbers = primaryAgreementMap.values();

			if (primaryAgmtNumbers.contains(currentAgmtNumber)) {
				/*
				 * If the current agreement is the primary agreement, set the
				 * primaryAgreement boolean to TRUE in the context AgreementDTO
				 * object.
				 */
				return true;
			} else {
				return false;
			}

		} else {
			/*
			 * If the primaryAgreementMap is null/Empty, set the
			 * primaryAgreement boolean to FALSE in the context AgreementDTO
			 * object.
			 */
			return false;
		}
	}

	// SSM2707 Added for Hierarchy FR3.5 Primary Agreement SWETA MENON End

	/**
	 * Compare the before and after MaintainAgreementDTO image to determine if
	 * MaintainAgreementCodes request should be raised
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	private boolean isMaintainAgreementCodesRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO().getAssociatedCodes() == null) {
			return false;
		}
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getAssociatedCodes() == null) {
			return true;
		}
		AgreementCodesDTO current = maintainAgreementDTO.getAgreementDTO()
				.getAssociatedCodes();
		AgreementCodesDTO previous = previousMaintainAgreementDTO
				.getAgreementDTO().getAssociatedCodes();
		return !current.equals(previous);
	}

	/**
	 * Compare the before and after MaintainAgreementDTO image to determine if
	 * MaintainDistributionDetails request should be raised
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	private boolean isMaintainDistributionDetailsRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO()
						.getDistributionDetails() == null) {
			return false;
		}
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getDistributionDetails() == null) {
			return true;
		}
		DistributionTemplateDTO currentClone = (DistributionTemplateDTO) SerializationUtils
				.clone(maintainAgreementDTO.getAgreementDTO()
						.getDistributionDetails());
		DistributionTemplateDTO previousClone = (DistributionTemplateDTO) SerializationUtils
				.clone(previousMaintainAgreementDTO.getAgreementDTO()
						.getDistributionDetails());
		return !currentClone.equals(previousClone);
	}

	/**
	 * Added for Differential pricing on 06/10/2010-pks2802 Private method to
	 * compare the before and after image of maintainAgreementDTO to determine
	 * of AdvisorQuality Code Details has changed
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return boolean
	 */

	private boolean isMaintainAdvisorQualityCodeRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO()
						.getAdvisorQualityCodeDTO() == null) {
			return false;
		}
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getAdvisorQualityCodeDTO() == null) {
			return true;
		}

		AdvisorQualityCodeDTO currentClone = (AdvisorQualityCodeDTO) SerializationUtils
				.clone(maintainAgreementDTO.getAgreementDTO()
						.getAdvisorQualityCodeDTO());
		AdvisorQualityCodeDTO previousClone = (AdvisorQualityCodeDTO) SerializationUtils
				.clone(previousMaintainAgreementDTO.getAgreementDTO()
						.getAdvisorQualityCodeDTO());
		return !currentClone.equals(previousClone);
	}
	
	private boolean isMaintainMaxUpfronCommPercentRequestAllowed(MaintainAgreementDTO maintainAgreementDTO, MaintainAgreementDTO previousMaintainAgreementDTO){
		
		/*
		if (maintainAgreementDTO != null 
				&& maintainAgreementDTO.getAgreementDTO() != null 
				&& maintainAgreementDTO.getAgreementDTO().getAdvisorQualityCodeDTO() != null 
				&& maintainAgreementDTO.getAgreementDTO().getAdvisorQualityCodeDTO().getAqcDetailsWithTypeDTO() != null
				&& !maintainAgreementDTO.getAgreementDTO().getAdvisorQualityCodeDTO().getAqcDetailsWithTypeDTO().isEmpty()) {
			
			for (AQCDetailsWithTypeDTO dto : maintainAgreementDTO.getAgreementDTO().getAdvisorQualityCodeDTO().getAqcDetailsWithTypeDTO()) {
				if (dto != null && dto.getMaxUpfrontCommPercent() != null) {
					return true;
				}
			}
		}*/
		
		return false;
		
	}

	/**
	 * Check if medical aid request should be raised
	 * 
	 * @param medicalCurrent
	 * @param medicalBefore
	 * @return
	 */
	private boolean isMaintainMedicalAidRequestAllowedForAddAgreement(
			MedicalAidDetailDTO medicalCurrent,
			MedicalAidDetailDTO medicalBefore) {
		if (medicalCurrent == null) {
			return false;
		} else if (medicalBefore == null && medicalCurrent != null
				&& medicalCurrent.isHasMedicalAid()) {
			return true;
		}
		return (ComparatorUtil.compareObjects(medicalCurrent, medicalBefore,
				true).size() != 0);
	}

	// SSM2707 Hierarchy FR3.4 FAIS Details SWETA MENON Begin
	private boolean isMaintainFAISDetailsRequestAllowedForAddAgreement(
			AgreementDTO agmtDTO) {
		String contextSalesCat = agmtDTO.getSalesCategory();
		List<String> excludeSalesCat = getSalesCategoryWithoutFAIS();
		if (excludeSalesCat.contains(contextSalesCat)) {
			return false;
		}

		return true;

	}

	public List<String> getSalesCategoryWithoutFAIS() {
		return salesCategoriesMapEntityManager.getSalesCategoryWithoutFAIS();
	}

	// SSM2707 Hierarchy FR3.4 FAIS Details SWETA MENON End
	// Market Integration 3rd Mar 2016 SWETA MENON Begin
	public List<SalesCategoriesMapEntity> getSalesCategoryForServicingPanel() {
		return salesCategoriesMapEntityManager
				.getSalesCategoryForServicingPanel();
	}

	// Market Integration 3rd Mar 2016 SWETA MENON End

	/**
	 * Added for Differential pricing on 21/12/2010-pks2802 Private method to
	 * check whether maintainAQC Request is to be raised for Add Agreements
	 * 
	 * @param maintainAgreementDTO
	 * @return boolean
	 */

	private boolean isMaintainAdvisorQualityCodeRequestAllowedForAddAgreement(
			MaintainAgreementDTO maintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO()
						.getAdvisorQualityCodeDTO() == null) {
			return false;
		}

		AdvisorQualityCodeDTO advisorQualityCodeDTO = maintainAgreementDTO
				.getAgreementDTO().getAdvisorQualityCodeDTO();
		boolean isAqcModified = false;

		outer: for (AQCDetailsWithTypeDTO detailsWithTypeDTO : advisorQualityCodeDTO
				.getAqcDetailsWithTypeDTO()) {

			List<AQCDTO> manualAQCDtos = detailsWithTypeDTO != null ? detailsWithTypeDTO
					.getManualAQCDTOs() : null;
			if (manualAQCDtos != null) {
				for (AQCDTO aqcdto : manualAQCDtos) {
					if (aqcdto.isMaintainable()) {
						isAqcModified = true;
						break outer;
					}
				}
			}
		}

		return isAqcModified;
	}

	/**
	 * Added for Fit and proper supervision maintainance Private method to
	 * compare the before and after image of maintainAgreementDTO to determine
	 * of Supervision Details has changed
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return boolean
	 */

	private boolean isMaintainAgreementSupervisors(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		List<AgreementRoleDTO> otherRoles = new ArrayList<AgreementRoleDTO>(
				maintainAgreementDTO.getAgreementDTO()
						.getCurrentAndFutureSupervisorRoles());
		for (AgreementRoleDTO role : maintainAgreementDTO.getAgreementDTO()
				.getCurrentAndFutureSupervisorRoles()) {
			if (role.getKind() == RoleKindType.ISSERVICEDBY.getKind()
					|| role.getKind() == RoleKindType.HASBUSINESSSTAKEHOLDER
							.getKind()) {
				otherRoles.remove(role);
			}
		}
		List<AgreementRoleDTO> otherRolesOld = new ArrayList<AgreementRoleDTO>();
		if (previousMaintainAgreementDTO.getAgreementDTO()
				.getCurrentAndFutureSupervisorRoles() != null) {
			otherRolesOld = new ArrayList<AgreementRoleDTO>(
					previousMaintainAgreementDTO.getAgreementDTO()
							.getCurrentAndFutureSupervisorRoles());
			for (AgreementRoleDTO role : previousMaintainAgreementDTO
					.getAgreementDTO().getCurrentAndFutureSupervisorRoles()) {
				if (role.getKind() == RoleKindType.ISSERVICEDBY.getKind()
						|| role.getKind() == RoleKindType.HASBUSINESSSTAKEHOLDER
								.getKind()) {
					otherRolesOld.remove(role);
				}
			}
		}
		return (ComparatorUtil.compareObjects(otherRoles, otherRolesOld, true)
				.size() != 0);
	}

	/**
	 * Compare the before and after MaintainAgreementDTO image to determine if
	 * MaintainPoolAccount request should be raised
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	private boolean isPoolAccountRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO().getKind() != AgreementKindType.FRANCHISE
						.getKind()
				|| maintainAgreementDTO.getAgreementDTO()
						.getFranchisePoolAccount() == null) {
			/**
			 * If agreement is not franchise and there is no pool account DTO
			 * set, then the request is not allowed
			 */
			return false;
		}
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getFranchisePoolAccount() == null) {
			return true;
		}
		FranchisePoolAccountDTO current = maintainAgreementDTO
				.getAgreementDTO().getFranchisePoolAccount();
		FranchisePoolAccountDTO previous = previousMaintainAgreementDTO
				.getAgreementDTO().getFranchisePoolAccount();
		return !current.equals(previous);
	}

	/**
	 * Compare the before and after MaintainAgreementDTO image to determine if
	 * MaintainIntermediaryAgreement request should be raised
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	private boolean isMaintainIntermediaryAgreementRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null) {
			return false;
		}
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null) {
			return true;
		}

		try {
			AgreementDTO currentClone = maintainAgreementDTO.getAgreementDTO()
					.getAgreementDTOForRequestComparison(
							RequestKindType.MaintainIntermediaryAgreement);
			AgreementDTO previousClone = (AgreementDTO) previousMaintainAgreementDTO
					.getAgreementDTO().getAgreementDTOForRequestComparison(
							RequestKindType.MaintainIntermediaryAgreement);
			return !currentClone.equals(previousClone);
		} catch (InvalidConformanceTypeException e) {
			SystemException sys = new SystemException(
					"Cannot do AgreementDTO comparison when checking for "
							+ "MaintainIntermediaryAgreement ", 0, 0);
			sys.initCause(e);
			throw sys;
		}
	}

	/**
	 * Compare the before and after MaintainAgreementDTO image to determine if
	 * CreateServicingPanel request should be raised
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	private boolean isCreateServicingPanelRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null) {
			return false;
		}
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null) {
			return true;
		}

		try {
			AgreementDTO currentClone = maintainAgreementDTO.getAgreementDTO()
					.getAgreementDTOForRequestComparison(
							RequestKindType.CreateServicingPanel);
			AgreementDTO previousClone = (AgreementDTO) previousMaintainAgreementDTO
					.getAgreementDTO().getAgreementDTOForRequestComparison(
							RequestKindType.CreateServicingPanel);

			// if the Sales category is changed to a value that needs a panel
			// Case 1:Sales Category changed from a value that has a panel to
			// another value that also needs a
			List<SalesCategoriesMapEntity> servPanel = getSalesCategoryForServicingPanel();
			// panelCatefo

			return !currentClone.equals(previousClone);
		} catch (InvalidConformanceTypeException e) {
			SystemException sys = new SystemException(
					"Cannot do AgreementDTO comparison when checking for "
							+ "MaintainIntermediaryAgreement ", 0, 0);
			sys.initCause(e);
			throw sys;
		}
	}

	public boolean doesAgreementExist(long agreementNo) {

		try {
			agreementManagement.findAgreementWithSRSAgreementNr(agreementNo);
		} catch (CommunicationException e) {
			logger.fatal("CommunicationException while searching for Agreements");
			return false;
		} catch (DataNotFoundException e) {
			return false;
		}

		return true;

	}

	public void validateCommKindsForAddAssociatedAgmt(long agreementNo,
			int commKind) throws ValidationException {
		try {
			agreementManagement.validateCommKindsForAddAssociatedAgmt(
					agreementNo, commKind);
		} catch (DataNotFoundException e) {
			throw new ValidationException(e.getMessage());
		} catch (ValidationException e) {
			throw e;
		}
	}

	public List<Long> getSRSAgreementNumbersWithStatusReasonFraudForIdentificationNumber(
			long typeOid, String identificationNumber) {
		List<Long> ret = new ArrayList<Long>();
		try {
			List<ResultPartyDTO> parties = null;
			if (typeOid == SRSType.PERSON) {
				parties = partyManagement
						.findPartyWithIdentityNumber(identificationNumber);
			} else if (typeOid == SRSType.ORGANISATION) {
				parties = partyManagement
						.findPartyWithOrganisationRegistrationNumber(
								identificationNumber, null);
			}
			if (parties != null) {
				for (ResultPartyDTO party : parties) {
					try {
						List<ResultAgreementDTO> agreements = agreementManagement
								.findAgreementWithParty(party.getOid());
						if (agreements != null) {
							for (ResultAgreementDTO agreement : agreements) {
								/**
								 * Perform a query to lookup the status reason
								 * for this agreement
								 */
								try {
									String statusReason = findStatusReasonForAgreementObjectId(agreement
											.getOid());
									if (statusReason.toLowerCase().contains(
											"fraud")) {
										ret.add(agreement.getOid());
									}
								} catch (DataNotFoundException e) {
									// skip this agreement, no status reason
									// property
									logger.warn("No status reason property found for "
											+ "agreement with id : "
											+ agreement.getOid());
								}
							}
						}
					} catch (DataNotFoundException e) {
						// no agreements found for party, skip this party
					}
				}
			}
		} catch (DataNotFoundException e) {
			// no data found, ignore
		}
		return ret;
	}

	/**
	 * Find the active status reason for the agreement with the specified id
	 * 
	 * @param agreementId
	 * @return
	 * @throws DataNotFoundException
	 */
	private String findStatusReasonForAgreementObjectId(Long agreementId)
			throws DataNotFoundException {

		/* Initialise */
		Query query = QueryHelper.getBusinessLayerQuery("Agreement",
				"SRS_getStatusReasonForAgreementObjectId");
		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;
		Connection connection = null;

		try {
			/* Setup connection & query */
			connection = agreementDataSource.getConnection();
			preparedStatement = connection.prepareStatement(query.getQuery());
			preparedStatement.setObject(1, agreementId);

			resultSet = preparedStatement.executeQuery();

			if (resultSet.next() == false) {
				throw new DataNotFoundException("Status Reason not found for "
						+ "agreement id: " + agreementId);
			}

			return resultSet.getString("StatusReason");

		} catch (SQLException e) {
			e.printStackTrace();
			throw new CommunicationException(e);
		} finally {
			try {
				if (resultSet != null) {
					resultSet.close();
				}
				if (preparedStatement != null) {
					preparedStatement.close();
				}
			} catch (Exception e) {
				logger.warn("Unable to clean up connection", e);
			}
		}

	}

	/**
	 * Set up agreement role data for one grid row
	 * 
	 */
	public void setUpAgreementGridRoleData(AgreementRoleGridDTO gridRow) {
		if (gridRow.getAgreementParty() == null
				|| gridRow.getAgreementParty().getOid() <= 0) {
			try {
				if (gridRow.getRole().getRolePlayerReference() instanceof ResultPartyDTO
						&& gridRow.getRole().getKind() == SRSType.REPORTSTO) {
					// this means the agreement reports to a party that is not
					// an intermediary
					gridRow.setAgreementParty((ResultPartyDTO) gridRow
							.getRole().getRolePlayerReference());
					// we now create a blank agreement role reference
				} else {
					gridRow.setAgreementParty(partyManagement
							.findPartyIntermediaryWithAgreementNr(gridRow
									.getRole().getRolePlayerReference()
									.getOid()));
				}
			} catch (DataNotFoundException e1) {
				// display error
				ResultPartyDTO party = new ResultPartyDTO();
				party.setName("Unknown");
				gridRow.setAgreementParty(party);
				logger.error("Agreement "
						+ gridRow.getRole().getRolePlayerReference().getOid()
						+ " party data could not be found");
			}
		}
		// get the home if it is linked to one
		try {
			Collection<AgreementRoleDTO> hasHomeRole = agreementManagement
					.getAgreementRoleDTOForAgreement(gridRow.getRole()
							.getRolePlayerReference().getOid(),
							RoleKindType.HASHOME);
			if (hasHomeRole.size() > 0) {
				AgreementRoleDTO homeRole = hasHomeRole.iterator().next();
				if (homeRole.getRolePlayerReference() != null) {
					ResultPartyDTO home = partyManagement
							.findPartyWithObjectOid(homeRole
									.getRolePlayerReference().getOid());
					gridRow.setAgreementHome(home);
				}
			}
		} catch (DataNotFoundException e) {
			// no problem, unit will be blank
		}
	}

	/**
	 * Set up agreement role data for one grid row
	 * 
	 */
	public void setUpAgreementPartnerRolesGridData(
			AgreementPartnerRolesGridDTO gridRow) {
		String name = "Unknown";
		List<Long> rolePlayerIdList = new ArrayList<Long>();
		List<AgreementRoleDTO> agreementDetailList = null;
		long agreementNum = 0;

		if (gridRow.getRole() != null || gridRow.getAgreementNr() <= 0) {
			try {

				PartyNameAgreementFLO agreementFLO = null;

				if (gridRow.getRole().getKind().intValue() == RoleKindEnumeration._INASSOCIATIONWITH) {
					rolePlayerIdList = new ArrayList<Long>();
					rolePlayerIdList.add(gridRow.getAgreementNr());
					agreementDetailList = agreementEntityManager
							.findAgreementRolesOfTypeForRolePlayers(
									rolePlayerIdList,
									RoleKindType.INASSOCIATIONWITH,
									AgreementRoleDTO.class);
					if (agreementDetailList != null
							&& !agreementDetailList.isEmpty()) {
						agreementNum = agreementDetailList.get(0)
								.getAgreementNumber();
						agreementFLO = (PartyNameAgreementFLO) entityManager
								.findPartyNamesForAgreements(
										agreementDetailList.get(0)
												.getAgreementNumber(),
										PartyNameAgreementFLO.class);
					} else {
						agreementNum = gridRow.getAgreementNr();
						rolePlayerIdList = new ArrayList<Long>();
						rolePlayerIdList.add(gridRow.getAgreementNr());
						agreementDetailList = agreementEntityManager
								.findAgreementRolesOfTypeForAgreements(
										rolePlayerIdList,
										RoleKindType.INASSOCIATIONWITH,
										AgreementRoleDTO.class, true);

						agreementNum = agreementDetailList.get(0)
								.getRolePlayerReference().getOid();
						agreementFLO = (PartyNameAgreementFLO) entityManager
								.findPartyNamesForAgreements(agreementNum,
										PartyNameAgreementFLO.class);

					}
				} else {
					agreementNum = gridRow.getRole().getAgreementNumber();
					agreementFLO = (PartyNameAgreementFLO) entityManager
							.findPartyNamesForAgreements(agreementNum,
									PartyNameAgreementFLO.class);
				}

				name = (agreementFLO != null ? agreementFLO.getName() : name);

				gridRow.setName(name);

				gridRow.setKind(gridRow.getRole().getKind());
				gridRow.setAgreementRoleKind(agreementNum);
				gridRow.setEffectiveFrom(gridRow.getRole().getEffectiveFrom());
				gridRow.setEffectiveTo(gridRow.getRole().getEffectiveTo());
				gridRow.setType(gridRow.getRole().getType());

			} catch (Exception e1) {
				// display error
				PartyNameAgreementFLO party = new PartyNameAgreementFLO();
				gridRow.setName(name);
				logger.error("Agreement "
						+ gridRow.getRole().getRolePlayerReference().getOid()
						+ " party data could not be found");
			}
		}
	}

	/**
	 * Returns all the servicing type ie Growth Consultant etc
	 * 
	 * @return
	 * @throws DataNotFoundException
	 */
	public List<TypeVO> getServicingTypeList() throws DataNotFoundException {
		return agreementManagement.getServicingTypeList();
	}

	/**
	 * Will return the allowable role type selection values for an agreement to
	 * a specific component
	 * 
	 * @return
	 * @throws ProductNotFoundException
	 * @throws DataNotFoundException
	 * @throws ValidationException
	 */

	public List<TypeVO> getBusinessStakeHolderTypeList()
			throws DataNotFoundException {
		return agreementManagement.getBusinessStakeHolderTypeList();
	}

	/**
	 * Returns all the business stakeholder types ie Business Owner
	 * 
	 * @return
	 * @throws DataNotFoundException
	 */
	public Collection<RoleKindType> getAllowableRoleTypesForAgreement(
			long agreementSpecificationID, ProjectBaseType toComponent)
			throws ProductNotFoundException {
		return agreementManagement.getAllowableRoleTypesForAgreement(
				agreementSpecificationID, toComponent);
	}

	/**
	 * Will return the parent node of the given Hierarchy node
	 * 
	 * @return
	 * @throws DataNotFoundException
	 */
	public ResultPartyDTO findParentOfHierarchyNode(long partyOID,
			long partyTypeOID) throws DataNotFoundException {
		return partyManagement
				.findParentOfHierarchyNode(partyOID, partyTypeOID);
	}

	/**
	 * Will return the manager of the given Hierarchy node
	 * 
	 * @return
	 * @throws DataNotFoundException
	 */
	public ResultPartyDTO findHierarchyNodeManager(long partyOID,
			long partyTypeOID) throws DataNotFoundException {
		return partyManagement.findHierarchyNodeManager(partyOID, partyTypeOID);
	}

	/**
	 * Validate all current agreement roles
	 * 
	 * @param roles
	 *            All the current agreement role, do not send in old roles as
	 *            they will also be validated
	 * @throws ValidationException
	 */
	public void validateAgreementRoles(long agreementNumber,
			long agreementKind, Date agreementStartDate,
			Collection<AgreementRoleDTO> currentAndFutureRoles,
			Collection<AgreementRoleDTO> pastRoles) throws ValidationException {
		agreementValidator.validateAgreementRoles(agreementNumber,
				agreementKind, agreementStartDate, currentAndFutureRoles,
				pastRoles);
	}

	public void validateSalesCategory(String salesCategory)
			throws ValidationException {
		agreementValidator.validateSalesCategory(salesCategory);
	}

	public void validateThirteenDigitCode(AgreementHomeRoleDTO data)
			throws ValidationException {
		agreementValidator.validateThirteenDigitCode(data != null ?data.getConsultantCode():null,0);
	}

	/**
	 * Validate pays to details
	 * 
	 * @param existingAgreementId
	 *            The id of the agreement, or null if it is a new agreement.
	 * @param paysTo
	 *            the pays to details of the agreement.
	 */
	public void validatePaysToDTO(Long existingAgreementId, PaysToDTO paysTo)
			throws ValidationException {
		agreementValidator.validatePaysToDTO(existingAgreementId, paysTo);
	}

	/**
	 * Do an agreement search with an SRS Agreement Nr
	 * 
	 * @param srsAgreementNr
	 * @return
	 * @throws DataNotFoundException
	 * @throws CommunicationException
	 */
	public ResultAgreementDTO findAgreementWithSRSAgreementNr(
			long srsAgreementNr) throws DataNotFoundException,
			CommunicationException {
		return agreementManagement
				.findAgreementWithSRSAgreementNr(srsAgreementNr);
	}

	/**
	 * Do a hierarchy node search using an external reference
	 * 
	 * @param organisationName
	 * @param searchOptionsDTO
	 * @return
	 * @throws DataNotFoundException
	 */
	public List<ResultPartyDTO> findHierarchyNodeWithExternalReference(
			String externalrefernce,
			ContractingSearchOptionsDTO searchOptionsDTO)
			throws DataNotFoundException {
		return partyManagement.findHierarchyNodeWithExternalReference(
				externalrefernce, searchOptionsDTO);
	}

	/**
	 * Finds the party name of an agreement
	 * 
	 * @param agreementNumber
	 * @return
	 * @throws DataNotFoundException
	 */
	public IPartyNameAgreementFLO findPartyNameForAgreement(long agreementNumber)
			throws DataNotFoundException {
		return partyManagement.findPartyNameForAgreement(agreementNumber);
	}

	@SuppressWarnings("unchecked")
	public List<DistributionTemplateHistoryDTO> getTemplateHistoryForAgreementNo(
			AgreementDTO agreementDTO) {
		List<DistributionTemplateHistoryDTO> retList = new ArrayList<DistributionTemplateHistoryDTO>();
		try {
			List<DistributionTemplateHistoryDTO> templateHistory = agreementManagement
					.findTemplateHistoryForAgmtCode(agreementDTO.getId());

			if (templateHistory == null)
				return Collections.EMPTY_LIST;

			for (DistributionTemplateHistoryDTO historyDTO : templateHistory) {
				if (historyDTO.getTemplateId() == null) {
					logger.fatal("TemplateID is null while fetching History");
					return Collections.EMPTY_LIST;
				}

				Description description = descriptionManager
						.findValueByUniqueID(historyDTO.getTemplateId());
				if (description != null)
					historyDTO.setTemplateDesc(description.getDescription());
				retList.add(historyDTO);
			}

			Collections.sort(retList,
					Collections.reverseOrder(new EffectiveToDateComparator()));

			return retList;

		} catch (CommunicationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (DataNotFoundException e) {
			// No History Found
		}
		return Collections.EMPTY_LIST;

	}

	private class EffectiveToDateComparator implements
			Comparator<DistributionTemplateHistoryDTO> {

		public int compare(DistributionTemplateHistoryDTO o1,
				DistributionTemplateHistoryDTO o2) {
			// TODO Auto-generated method stub
			return DateUtil.compareDates(o1.getEffectiveTo(),
					o2.getEffectiveTo());
		}

	}

	public List<Long> getBankAgreementNumbers() {
		List<BankCode> list = bankCodesEntityManager.findAllBankCodes();
		List<Long> ret = new ArrayList<Long>();
		ret.add(612l);
		return ret;
	}

	public ContextDTO getAgreementContext(long agreementId)
			throws DataNotFoundException, CommunicationException {
		ResultAgreementDTO agreement = agreementManagement
				.findAgreementWithSRSAgreementNr(agreementId);
		ResultPartyDTO party = partyManagement
				.findPartyIntermediaryWithAgreementNr(agreementId);
		return contextManagement.getContext(party, agreement);
	}

	public void broadcastAgreement(long agreementId)
			throws DataNotFoundException, SecurityException {
		AgreementVO agreementVO = agreementManagement
				.getAgreementVOWithObjectOID(agreementId);
		Broadcast_Action actionType = agreementVO != null
				&& agreementVO.getCurrentStatus() != null
				&& agreementVO.getCurrentStatus()
						.equalsIgnoreCase("Terminated") ? Broadcast_Action.TERMINATE
				: Broadcast_Action.UPDATE;
		UserSecurityProfile userSecurityProfile;
		try {
			userSecurityProfile = securityContextBPOHome.create()
					.getUserSecurityProfile();
		} catch (RemoteException e) {
			throw new CommunicationException(
					"Could not get security context bean", e);
		} catch (CreateException e) {
			throw new CommunicationException(
					"Could not create security context bean", e);
		}
		agreementIntegrationController.broadcastAgreementSynchronous(
				agreementVO, userSecurityProfile.getPartyOid(), actionType);
	}

	public PaymentSchedulerDTO getPaymentSchedulerDTOForPaysTO(long agreementId)
			throws DataNotFoundException, ConformanceTypeException {
		AgreementVO agreementVO = agreementManagement
				.getAgreementVOWithObjectOID(agreementId);
		return agreementConverter
				.getPaymentSchedulerDTOFromAgreementVO(agreementVO);

	}

	/**
	 * Method to retrieve Advisor Quality Code Details For a party
	 * 
	 * @param Party
	 *            DTO
	 * @return AdvisorQualityCodeDTO
	 */

	public AdvisorQualityCodeDTO getAdvisorQualityCodeDetailsForParty(
			PartyDTO party) throws DataNotFoundException,
			ConformanceTypeException {
		if (party == null)
			return null;

		ObjectReference partyRef = new ObjectReference(
				Constants.PARTY_COMPONENT_ID, party.getTypeOID(),
				party.getOid());
		return partyManagement.getAdvisorQualityCodesForPartyObjRef(partyRef);
	}

	/**
	 * Method to retrieve SegmentType For Add Agreement based on passed
	 * Agreement Home Roles (selected in Hierarchy) & agreement Kind
	 * 
	 * @param List
	 *            of AgreementHomeRoleDTO
	 * @param List
	 *            of AgreementRoleDTO
	 * @param agreementKind
	 * @return SegmentDTO
	 */
	public SegmentDTO getApplicableSegmentTypeForAddAgreement(
			List<AgreementHomeRoleDTO> agmtHomeRoles,
			List<AgreementRoleDTO> agmtRoles, int agmtKind) {

		SegmentDTO segmentDTO = null;
		boolean defaultSegmentReq = false;
		boolean isBelongsToExist = false;
		long belongsToRolePlayerId = 0l;

		if (agmtHomeRoles == null || agmtHomeRoles.size() == 0)
			return agreementManagement
					.getDefaultSegmentTypeForAgreementKind(agmtKind);

		if (agmtHomeRoles.size() > 1)
			return agreementManagement
					.getDefaultSegmentTypeForAgreementKind(agmtKind);

		AgreementHomeRoleDTO agreementHomeRoleDTO = agmtHomeRoles.get(0);// There
																			// should
																			// be
																			// only
																			// 1
																			// Home
																			// Role
		if (agmtRoles != null && agmtRoles.size() > 0) {
			for (AgreementRoleDTO agreementRoleDTO : agmtRoles) {
				if (agreementRoleDTO.getKind() == RoleKindEnumeration.BELONGSTO
						.getValue()) {
					belongsToRolePlayerId = agreementRoleDTO.getRolePlayerID();
					isBelongsToExist = true;
					break;
				}

			}
		}

		if (isBelongsToExist) {
			try {
				segmentDTO = agreementManagement
						.getSegmentDTOForBelongsToRolePlayerId(belongsToRolePlayerId);
				if (segmentDTO != null)
					return segmentDTO;
			} catch (DataNotFoundException e) {
				// Do Nothing proceed to look for SegmentDTO based on Has
				// Home.....
			}

		}

		try {
			segmentDTO = agreementManagement
					.getSegmentTypeForBranch(agreementHomeRoleDTO
							.getRolePlayerID());
			if (segmentDTO == null)
				defaultSegmentReq = true;
		} catch (DataNotFoundException e) {
			defaultSegmentReq = true;
		} catch (InconsistentDataException e) {
			defaultSegmentReq = true;
		}

		return defaultSegmentReq ? agreementManagement
				.getDefaultSegmentTypeForAgreementKind(agmtKind) : segmentDTO;

	}

	/**
	 * Method to retrieve Effective AQC values for Add Agreement based on
	 * AdvisorQualityCodeDTO & SegmentType
	 * 
	 * @param AdvisorQualityCodeDTO
	 * @param SegmentDTO
	 * @return List of EffectiveAQCDTO
	 */

	public List<EffectiveAQCDTO> getEffectiveAQCValuesForAddAgreement(
			AdvisorQualityCodeDTO advisorQualityCodeDTO, SegmentDTO segment) {

		return agreementManagement.getEffectiveAQCValuesForAQCDTOAndSegment(
				advisorQualityCodeDTO, segment);

	}

	/**
	 * Return true if this party has any banking details linked to him
	 */
	public boolean hasPartyBankingDetails(long partyOid) {
		try {
			partyManagement.getBankingDetailsBratlinkWithObjectOid(partyOid);
			return true;
		} catch (DataNotFoundException e) {
			return false;
		}
	}

	/**
	 * 
	 */
	public void validateSupervision(
			List<FAISCategorySupervisionDTO> supervisionDTOs,
			Date categoryStartDate, String categoryID, Date agreementStartDate)
			throws ValidationException {
		agreementValidator.validateSupervision(supervisionDTOs,
				categoryStartDate, categoryID, agreementStartDate);

	}

	// /**Retrievs FSP license number for the agreement number.
	// *
	// * @param long agreementNumber
	// */
	// public String getFSPLicenseNumberForAgreementNumber(long agreementNumber)
	// throws DataNotFoundException {
	// String faisLicenseNumber = null;
	// long belongsToOID = getBelongsToAgreement(agreementNumber);
	// // find the license number of FSP
	// faisLicenseNumber = partyEntityManager
	// .getFSPLicenceNumber(belongsToOID);
	// // if there isnt any license number throw exception
	// if (faisLicenseNumber == null) {
	// throw new DataNotFoundException(
	// "No FSP Number for agreement : "
	// + agreementNumber);
	//
	// }
	// return faisLicenseNumber;
	// }
	//

	/**
	 * Gets the belongs to for the agreementNumber
	 * 
	 * @throws DataNotFoundException
	 *             thrown if no belongs to role found for the agreement
	 */
	public long getBelongsToAgreement(long agreementNumber)
			throws DataNotFoundException {
		ObjectReference ref = agreementManagement
				.getRolePlayerReferenceForAgreement(agreementNumber,
						RoleKindType.BELONGSTO.getKind());
		return ref.getObjectOid();
	}

	/**
	 * Gets the agreement simple details fro an agreement number
	 * 
	 * @param agreementNumber
	 * @return
	 * @throws CommunicationException
	 * @throws DataNotFoundException
	 */
	public IAgreementDetailFLO getAgreementsSimpleDetail(long agreementNumber)
			throws CommunicationException, DataNotFoundException {
		ArrayList<Long> agreementNumbers = new ArrayList<Long>();
		agreementNumbers.add(agreementNumber);
		List<IAgreementDetailFLO> flos = agreementManagement
				.findAgreementsSimpleDetail(agreementNumbers);
		if (flos == null || flos.size() == 0) {
			throw new DataNotFoundException(
					"Could not find agreement with agreement number "
							+ agreementNumber);
		}
		return flos.get(0);
	}

	/**
	 * This method returns all allowable fais license categories for agreement
	 * number.
	 * 
	 * @param agreementNumber
	 * @return
	 * @throws DataNotFoundException
	 */
	/*
	 * public List<FAISCategoriesDBEnumDTO>
	 * getAllAllowedFaisLicenseCategoriesUsingFSPLicenceDetail( FAISLicenseDTO
	 * fspLicence) throws DataNotFoundException { // set all the categories in
	 * the list List<FAISCategoriesDBEnumDTO> categoriesDBEnumDTOs =
	 * DatabaseEnumHelper .getDatabaseDTO(FAISCategoriesDBEnumDTO.class); //
	 * check if fspLicence is not null and faislicense category inside it // are
	 * also not null if (fspLicence != null &&
	 * fspLicence.getFaisLicenseCategoryDTOs() != null) { //create new instance
	 * of categoriesDBEnumDTOs; categoriesDBEnumDTOs = new
	 * ArrayList<FAISCategoriesDBEnumDTO>(); // loop through all categories in
	 * fspLicense for (FAISLicenseCategoryDTO categoryDTO : fspLicence
	 * .getFaisLicenseCategoryDTOs()) { // add categories to
	 * categoriesDBEnumDTOs categoriesDBEnumDTOs .add((FAISCategoriesDBEnumDTO)
	 * DatabaseEnumHelper .getDatabaseEnumUsingKey(
	 * FAISCategoriesDBEnumDTO.class, categoryDTO.getCategoryid()));
	 * 
	 * }
	 * 
	 * return categoriesDBEnumDTOs;
	 * 
	 * } else if(fspLicence==null) {
	 * 
	 * return categoriesDBEnumDTOs;
	 * 
	 * } return null;
	 * 
	 * }
	 */

	/**
	 * This method returns all allowable fais license categories for agreement
	 * number.
	 * 
	 * @param agreementNumber
	 * @return
	 * @throws DataNotFoundException
	 */
	public List<TypeVO> getAllAllowedFaisLicenseCategoriesUsingFSPLicenceDetail(
			FAISLicenseDTO fspLicence) {
		// set all the categories in the list
		List<TypeVO> allCategories = null;
		try {
			allCategories = getFaisLicenseSubTypeList();
		} catch (DataNotFoundException e) {
			// TODO: handle exception
		}
		// check if fspLicence is not null and faislicense category inside it
		// are also not null
		if (fspLicence != null
				&& fspLicence.getFaisLicenseCategoryDTOs() != null) {
			// create list of categories specific to FSP;
			List<TypeVO> fspCategories = new ArrayList<TypeVO>();
			// loop through all categories in fspLicense
			for (FAISLicenseCategoryDTO categoryDTO : fspLicence
					.getFaisLicenseCategoryDTOs()) {
				fspCategories.add(getSupervisorType(categoryDTO.getTypeOid(),
						allCategories));

			}

			return fspCategories;

		} else if (fspLicence == null) {

			return allCategories;

		}

		return null;
	}

	/**
	 * Validates the faislicense details
	 * 
	 * @param faisDetails
	 * @param belongsToAgmtNo
	 */
	public void validateFAISLicenceDetails(FAISLicenseDTO faisDetails,
			Long belongsToAgmtNo, boolean isTied) throws ValidationException {

		agreementValidator.validateFAISLicenceDetails(faisDetails,
				belongsToAgmtNo, isTied);
	}

	/**
	 * This Method returns FaislicenseDTO of FSP for the agreementkind and
	 * belongsTo AgreementNumber
	 * 
	 * @param agreementKind
	 * @param belongsToAgtmNumber
	 * @return FAISLicenseDTO of FSP
	 * @throws DataNotFoundException
	 */
	public FAISLicenseDTO getFSPLicenceDetails(int agreementKind,
			Long repBelongsTO) throws DataNotFoundException {
		return agreementManagement.getFSPFAISLicence(agreementKind,
				repBelongsTO);
	}

	public boolean isTied(int agreementKind) throws DataNotFoundException {
		// TODO Auto-generated method stub
		return agreementManagement.isTied(agreementKind);
	}

	public List<IDValueDTO> getSubTypeList(long type)
			throws DataNotFoundException {
		List<IDValueDTO> typeListForCategories = partyManagement
				.getTypeListForCategories(type);
		return typeListForCategories;
	}

	/**
	 * Returns all the servicing type ie Growth Consultant etc
	 * 
	 * @return
	 * @throws DataNotFoundException
	 */
	public List<TypeVO> getFaisLicenseSubTypeList()
			throws DataNotFoundException {
		return agreementManagement.getFaisLicenseSubTypeList();
	}

	/**
	 * Set up agreement role data for one supervisor grid row
	 * 
	 */
	public void setUpOtherPartyGridRoleData(AgreementRoleGridDTO gridRow) {

		// get the supervisor if it is linked to one
		try {
			ResultPartyDTO agreementParty = partyManagement
					.findPartyWithObjectOid(gridRow.getRole()
							.getRolePlayerReference().getOid());
			gridRow.setAgreementParty(agreementParty);

		} catch (DataNotFoundException e) {
			// no problem, unit will be blank
		}
	}

	public ITypeFLO getType(long typeOid) throws DataNotFoundException {
		return agreementManagement.getType(typeOid);
	}

	/**
	 * get the supervisor type for this categoryid(typeOid)
	 * 
	 * @param typeID
	 * @return
	 */
	public TypeVO getSupervisorType(long typeID,
			List<TypeVO> faisLicenseSubTypeList) {
		if (faisLicenseSubTypeList != null) {
			for (TypeVO type : faisLicenseSubTypeList) {
				if (type.getOid() == typeID) {
					return type;
				}
			}
		}
		return null;
	}

	/**
	 * Validates the Agreement Statuses for “Failed Kroll checking” OR
	 * “Debarred” OR “S-Referenced
	 * 
	 * @param typeOid
	 * @param idNumber
	 * @throws ValidationException
	 * @throws CommunicationException
	 * @throws DataNotFoundException
	 */
	public void validateAllAgreementForDebarment(long partyOid)
			throws ValidationException, CommunicationException,
			DataNotFoundException {
		agreementValidator.validateAgreementsForDebarment(partyOid);

	}

	public List<PartyProfileFLO> findUserWithUACFID(String uacfid) {
		return profileManagement.findUserFastLaneWithUacfStartingWith(uacfid);
	}

	/**
	 * check the waiver end dates are in the future
	 * 
	 * @param agreementDTO
	 */
	public void validateWaiverDates(AgreementDTO agreementDTO)
			throws ValidationException {
		agreementValidator.validateWaiverDates(agreementDTO);
	}

	/**
	 * Find a party with object oid
	 * 
	 * @param objectOid
	 * @return
	 * @throws DataNotFoundException
	 */
	public ResultPartyDTO findPartyWithObjectOid(long objectOid)
			throws CommunicationException, DataNotFoundException {
		return partyManagement.findPartyWithObjectOid(objectOid);

	}

	/**
	 * Validate Supervisor Roles
	 * 
	 * @param agreementNumber
	 * @param agreementStartDate
	 * @param currentAndFutureRoles
	 * @param pastRoles
	 * @throws ValidationException
	 */
	public void validateAgreementRolesOfKind(long agreementNumber,
			long agreementKind, Date agreementStartDate,
			Collection<AgreementRoleDTO> currentAndFutureRoles,
			Collection<AgreementRoleDTO> pastRoles, Long agreementRoleKind)
			throws ValidationException {

		// List<Long> agmtNos = new ArrayList<Long>();
		// agmtNos.add(agreementNumber);
		// Long agreementKind =
		// agreementEntityManager.findAgreementsSimpleDetail(agmtNos).get(0).getKind();
		agreementValidator.validateAgreementRolesOfKind(agreementNumber,
				agreementKind, agreementStartDate, currentAndFutureRoles,
				pastRoles, agreementRoleKind);

	}

	/**
	 * Get the current Honesty And Integrity TimePeriod using the rating
	 * configuration
	 * 
	 * @return
	 * @throws CommunicationException
	 */
	public TimePeriod getCurrentHonestyAndIntegrityTimePeriod()
			throws CommunicationException {
		return agreementManagement.getCurrentHonestyAndIntegrityTimePeriod();
	}

	/**
	 * Find The My Banking Number for all the given agreements
	 * 
	 * @param agreementNumbers
	 * @return
	 */
	public List<IAgreementDetailWithMyBankNumFLO> findMyBankingNumbersForAgreements(
			List<Long> agreementNumbers) {

		return agreementEntityManager
				.findMyBankingNumbersForAgreements(agreementNumbers);
	}

	/**
	 * Find The Agreements for given My Banking Numbers
	 * 
	 * @param agreementNumbers
	 * @return
	 */
	public List<IAgreementDetailWithMyBankNumFLO> findAgreementsForMyBankingNumbers(
			List<Long> myBankingNos) {

		return agreementEntityManager
				.findAgreementsForMyBankingNumbers(myBankingNos);
	}

	/**
	 * Validate all incentive details
	 * 
	 * @param incetive
	 * @throws ValidationException
	 */
	public void validateIncentiveDetails(List<IncentiveDetailDTO> incentives,
			Date agreementStartDate, String currentAgreementStatus)
			throws ValidationException {
		agreementValidator.validateIncentiveDetails(incentives,
				agreementStartDate, currentAgreementStatus);
	}

	/**
	 * Validate one incentive detail
	 * 
	 * @param incentive
	 * @param agreementStartDate
	 */
	public void validateIncentiveDetail(IncentiveDetailDTO incentive,
			Date agreementStartDate, String currentAgreementStatus)
			throws ValidationException {
		agreementValidator.validateIncentiveDetail(incentive,
				agreementStartDate, currentAgreementStatus);
	}

	/**
	 * Return the SRScontext
	 * 
	 * @return
	 */
	public ComponentContext getSRSContext() {
		return contextProxy.getSRSContext();
	}

	public List<DistributionKindGroupRatesDTO> findDistributionKindGroupDTOTemplateID(
			int templateID) {

		return franchiseTemplateManagement
				.getDistributionKindGroupRatesByTemplateId(templateID);
	}

	public Description getTemplateDescriptionByTemplateID(int templateID) {

		return descriptionManager.findValueByUniqueID(templateID);
	}

	public List<Description> getValidDistributionKindGroupRatesByDKGKind(
			int dkgKind) {

		return franchiseTemplateManagement
				.getValidDistributionKindGroupRatesByDKGKind(dkgKind);

	}

	public List<Description> getScheduleDescriptions() {
		return franchiseTemplateManagement
				.getDescriptionByKind(DescriptionKindType.DISTRIBUTION_SCHEDULE_KIND
						.getKind());
	}

	/**
	 * Validate the medical aid credit indicator
	 * 
	 * @param agreementDTO
	 * @param previousVersion
	 * @throws ValidationException
	 */
	public void validateMedicalAidCreditIndicator(AgreementDTO agreementDTO)
			throws ValidationException {
		agreementValidator.validateMedicalAidCreditIndicator(agreementDTO);
	}

	/**
	 * Get all the ProductionClubStatus Values
	 * 
	 * @return
	 */
	public List<IDValueDTO> getAllProductionClubStatusValues() {
		return ratingEntityManager.getAllProductionClubStatus();
	}

	/**
	 * Validate the Manual Production Club status Property
	 * 
	 * @param agreementDTO
	 * @throws ValidationException
	 */
	public void validateManualProductionClubStatusProperty(
			AgreementDTO agreementDTO) throws ValidationException {
		agreementValidator
				.validateManualProductionClubStatusProperty(agreementDTO);
	}

	/**
	 * get the liberty Year end date for the current date given
	 * 
	 * @param currentDate
	 * @return
	 * @throws DataNotFoundException
	 *             if dates can not be found
	 */
	public Date getLibertyYearEndDate(Date currentDate)
			throws DataNotFoundException {
		MonthEndDates monthEndDates = businessUtilitiesBean
				.getLibertyMonthEndDates(currentDate);
		GregorianCalendar cal = new GregorianCalendar();
		cal.setTime(monthEndDates.getMonthStart());
		// get the start date and get the year;
		MonthEndDates yearEndDates = businessUtilitiesBean
				.getLibertyMonthEndDates(2, cal.get(GregorianCalendar.YEAR), 12);
		return yearEndDates.getMonthEnd();
	}

	/**
	 * Validate the Provident Fund Properties
	 * 
	 * @param agreementDTO
	 * @throws ValidationException
	 */
	public void validateProvidentFundDetails(
			ProvidentFundDetailDTO providentFundDetail, long agreementNo,
			String currentProvidentFundNumber) throws ValidationException {
		agreementValidator.validateProvidentFundDetails(providentFundDetail,
				agreementNo, currentProvidentFundNumber);

	}

	/**
	 * Returns true if the medical aid details should be linked
	 * 
	 * @param agreementDTO
	 * @param medicalAidDetailDTO
	 */
	public boolean isShowMedicalAidWarningOnAdd(AgreementDTO agreementDTO, MedicalAidDetailDTO medicalAidDetailDTO) {
	
		if (!ALLOW_MEDICAL_AGREEMENT_KINDS.contains(AgreementKindType.getAgreementKindType(agreementDTO.getKind()))) {	
			// Not the appropriate kind of agreement
			return false;
		}
		
		return (medicalAidDetailDTO != null 
				&& medicalAidDetailDTO.isHasMedicalAid() 
				&& agreementDTO.getHasMedicalAidCredits() != null
				&& (agreementDTO.getHasMedicalAidCredits().getValue() == null
				|| agreementDTO.getHasMedicalAidCredits().getValue().booleanValue()!=true));
	}
	
	/**
	 * Returns true if the medical aid details have changed
	 * 
	 * @param agreementDTO current
	 * @param agreementDTO previous
	 */
	public boolean isMedicalLinkChanged(AgreementDTO currentAgreement, AgreementDTO previousAgreement) {
	
		if (!ALLOW_MEDICAL_AGREEMENT_KINDS.contains(AgreementKindType.getAgreementKindType(currentAgreement.getKind()))) {	
			// Not the appropriate kind of agreement
			return false;
		}
		
		if (currentAgreement != null && currentAgreement.getId() > 0) {
			/*
			 * If there is a medical aid was it changed?  
			 */
			boolean currentActive = (currentAgreement.getHasMedicalAidCredits() != null 
					&& currentAgreement.getHasMedicalAidCredits().getValue() != null
					&& currentAgreement.getHasMedicalAidCredits().getValue());

			boolean previousActive = (
					previousAgreement != null
					&& previousAgreement.getHasMedicalAidCredits() != null 
					&& previousAgreement.getHasMedicalAidCredits().getValue() != null
					&& previousAgreement.getHasMedicalAidCredits().getValue());

			return (currentActive != previousActive);
		
		} 
		
		return false;
		
	}
	
	
	/**
	 * Find the latest request of a kind for an agreement
	 * 
	 * @param agreementNumber
	 * @param requestKind
	 * @throws RequestException
	 * @throws QueryTimeoutException
	 */
	private RequestVO findLatestRequestOfKindForAgreement(long agreementNumber,
			RequestKindType requestKind) throws RequestException,
			QueryTimeoutException {
		RequestEnquirySearchDTO searchDetails = new RequestEnquirySearchDTO();
		List<Long> agreementIDs = new ArrayList<Long>(1);
		agreementIDs.add(agreementNumber);
		searchDetails.setAgreementIdList(agreementIDs);
		List<RequestKindType> requestKinds = new ArrayList<RequestKindType>(1);
		requestKinds.add(requestKind);
		searchDetails.setRequestKindList(requestKinds);
		searchDetails.setRequestStatus(RequestStatusType.EXECUTED);
		RequestEnquiryResultDTO resultDto = requestEnquiryManagement
				.findRequests(searchDetails);
		IRequestEnquiryRow latest = null;
		if (resultDto != null && resultDto.getResultList() != null) {
			for (IRequestEnquiryRow row : resultDto.getResultList()) {
				if (latest == null
						|| row.getExecutedDate()
								.after(latest.getExecutedDate())
						|| (row.getExecutedDate().compareTo(
								latest.getExecutedDate()) == 0 && row
								.getRequestId() > latest.getRequestId())) {
					latest = row;
				}
			}
		}
		if (latest != null) {
			AgreementManagerBPO bpo;
			try {
				bpo = agreementManagerBPOHome.create();
			} catch (RemoteException e) {
				throw new CommunicationException(e);
			} catch (CreateException e) {
				throw new CommunicationException(e);
			}
			// get requestVO
			try {
				return bpo.getRequest(
						new ApplicationContext(),
						new AgreementObjectReference(-1, -1, latest
								.getRequestId()));
			} catch (OnlyActualNotFoundException e) {
				throw new CommunicationException("Request id "
						+ latest.getRequestId() + "found for agreement "
						+ agreementNumber
						+ " but this RequestVO could not be found", e);
			} catch (RemoteException e) {
				throw new CommunicationException(e);
			}
		}
		return null;
	}

	/**
	 * Get the latest provident fund values request and return all the details
	 * 
	 * @param agreementNumber
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public ProvidentFundRequestDetailDTO getLatestProvidentFundRequestDetail(
			long agreementNumber) {
		try {
			RequestVO request = findLatestRequestOfKindForAgreement(
					agreementNumber,
					RequestKindType.CalculateProvidentFundValues);
			if (request == null) {
				return null;
			}
			ProvidentFundRequestDetailDTO ret = new ProvidentFundRequestDetailDTO();
			ret.setRequestedDate(request.getRequestedDate());
			CurrencyAmount pensionableearnings = (CurrencyAmount) getPropertyFromRequest(
					request,
					PropertyKindEnumeration._ANNUALPENSIONABLEEARNINGSSNAPSHOT);
			ret.setAnnualPensionableEarnings((pensionableearnings != null) ? pensionableearnings
					.getValue() : null);
			ret.setAqcGroup((String) getPropertyFromRequest(request,
					PropertyKindEnumeration._RISKAQCGROUP));
			ret.setAqcScore((String) getPropertyFromRequest(request,
					PropertyKindEnumeration._RISKAQCVALUE));
			ret.setCalcEnd((Date) getPropertyFromRequest(request,
					PropertyKindEnumeration._CALCULATIONPERIODENDDATE));
			ret.setCalcStart((Date) getPropertyFromRequest(request,
					PropertyKindEnumeration._CALCULATIONPERIODSTARTDATE));
			BigDecimal contribRate = (BigDecimal) getPropertyFromRequest(
					request,
					PropertyKindEnumeration._PROVIDENTFUNDCONTRIBUTIONRATE);
			ret.setCalculationRate(new Percentage(
					(contribRate != null) ? contribRate : BigDecimal.ZERO));
			ret.setContributionAmount((BigDecimal) getPropertyFromRequest(
					request,
					PropertyKindEnumeration._PROVIDENTFUNDCONTRIBUTIONAMOUNT));
			CurrencyAmount monthlyPensionableEarnings = (CurrencyAmount) getPropertyFromRequest(
					request,
					PropertyKindEnumeration._MONTHLYPENSIONABLEEARNINGS);
			ret.setMonthlyPensionableEarnings((monthlyPensionableEarnings != null) ? monthlyPensionableEarnings
					.getValue() : null);
			ret.setOnePercentBondMemberEarnings((BigDecimal) getPropertyFromRequest(
					request,
					PropertyKindEnumeration._ONEPERCENTBONDMEMBEREARNINGAMOUNT));
			ret.setProductionClubStatus((String) getPropertyFromRequest(
					request,
					PropertyKindEnumeration._PRODUCTIONCLUBSTATUSSNAPSHOT));
			List<String> kindList = (List<String>) getPropertyFromRequest(
					request, PropertyKindEnumeration._BENEFITTYPENAMES);
			List<BigDecimal> benefitRates = (List<BigDecimal>) getPropertyFromRequest(
					request, PropertyKindEnumeration._RISKBENEFITRATE);
			List<BigDecimal> benefitAmounts = (List<BigDecimal>) getPropertyFromRequest(
					request, PropertyKindEnumeration._RISKBENEFITAMOUNT);
			List<BigDecimal> benefitPremiums = (List<BigDecimal>) getPropertyFromRequest(
					request, PropertyKindEnumeration._RISKBENEFITPREMIUM);
			List<BigDecimal> baseAmounts = (List<BigDecimal>) getPropertyFromRequest(
					request, PropertyKindEnumeration._RISKBENEFITBASE);
			// we assume order is correct
			int counter = 0;
			for (String kind : kindList) {
				ret.addBenefitDetail(kind, benefitAmounts.get(counter),
						benefitRates.get(counter), baseAmounts.get(counter),
						benefitPremiums.get(counter));
				counter++;
			}
			return ret;
		} catch (Exception e) {
			logger.warn(e.getMessage(), e);
			// just return null, means we could find the details
		}
		return null;
	}

	/**
	 * Get the property value from the request for a specified kind
	 * 
	 * @param request
	 * @param propertyKind
	 * @return
	 */
	private Object getPropertyFromRequest(RequestVO request, int propertyKind) {
		if (request == null || propertyKind < 0) {
			return null;
		}
		try {
			PropertyVO property = request.getPropertyOfKind(propertyKind);
			return property.getValue();
		} catch (KindNotFoundException e) {
			// ignore
		}
		return null;
	}

	/**
	 * Validate all the agreement codes
	 * 
	 * @param agreementNumber
	 * @param providentFundNumber
	 */
	public void validateAgreementCodes(AgreementCodesDTO agreementCodes,
			long agreementNumber, long agreementPartyID)
			throws ValidationException {
		agreementValidator.validateAgreementCodes(agreementCodes,
				agreementNumber, agreementPartyID);
	}

	/**
	 * Validate all the Rules for Sole Proprietor
	 * 
	 * @param agreementDTO
	 * @throws ValidationException
	 */
	public void validateSoleProprietorRules(AgreementDTO agreementDTO)
			throws ValidationException {
		// Validate only for BROKER & STOP ORDER BROKERS
		if (agreementDTO.getKind() != AgreementKindType.BROKER.getKind()
				&& agreementDTO.getKind() != AgreementKindType.STOP_ORDER_BROKER
						.getKind())
			return;
		// Validate only if SOLE PROPRIETOR is set to true
		if (!agreementDTO.getSoleProprietor())
			return;

		agreementValidator.validateSoleProprietorRules(agreementDTO);

	}
	
	/**
	 * Validate all the Rules for Scripted Advisor
	 * 
	 * @param agreementDTO
	 * @throws ValidationException
	 */
	public void validateScriptedAdvisor(AgreementDTO agreementDTO)
			throws ValidationException {
		// Validate only for BROKER & STOP ORDER BROKERS
		if (agreementDTO.getKind() != AgreementKindType.LIBERTY_ATWORK_COMMISSIONONLY.getKind())
			return;

		agreementValidator.validateScriptedAdvisor(agreementDTO);

	}
	/**
	 * Validate all the Rules for Include In Manpower Reporting RXS1408 - RAVISH
	 * SEGAL 08/07/14
	 * 
	 * @param agreementDTO
	 * @throws ValidationException
	 *             Edit State ADD
	 */
	public void validateIncludeInManpowerReportingRulesAddAgmt(
			AgreementDTO agreementDTO, PartyDTO partyDTO)
			throws ValidationException {
		agreementValidator.validateIncludeInManpowerReportingRulesAddAgmt(
				agreementDTO, partyDTO);
	}

	/**
	 * Validate all the Rules for Include In Manpower Reporting RXS1408 - RAVISH
	 * SEGAL 08/07/14
	 * 
	 * @param agreementDTO
	 * @throws ValidationException
	 *             Edit State MODIFY
	 */
	public void validateIncludeInManpowerReportingRulesMaintainAgmt(
			AgreementDTO agreementDTO) throws ValidationException {
		agreementValidator
				.validateIncludeInManpowerReportingRulesMaintainAgmt(agreementDTO);
	}

	/**
	 * Validate all the Rules for Hierarchy FR3.6 Employee Number - RXS1408 -
	 * RAVISH SEGAL
	 * 
	 * @param agreementDTO
	 * @throws ValidationException
	 */
	public void validateEmployeeNumber(AgreementDTO agreementDTO)
			throws ValidationException {
		try {
			agreementValidator.validateEmployeeNumber(agreementDTO);
		} catch (DataNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public void validateLBFHomeRole(AgreementDTO agreementDTO)
			throws ValidationException {
		agreementValidator.validateLBFHomeRole(agreementDTO);
	}

	public void validateLBFRemuration(AgreementDTO agreementDTO)
			throws ValidationException {
		agreementValidator.validateLBFRemuration(agreementDTO);
	}

	// SSM2707 Added for Hierarchy FR3.5 Primary Agreement SWETA MENON Begin
	/**
	 * This method analyzes if the input agreement number is of an in-force
	 * agreement.
	 * 
	 * An in-force agreement is one with status "Active" or
	 * "Retired with status reason Retired-Active"
	 * 
	 */
	public boolean isAgreementInForce(long agreementNumber, int kind) {

		/* Get the status and status reason value for the input agreement number */
		List<AgreementStatusAndStatusReasonFLO> agreementStatusAndStatusReasonFLO = agreementEntityManager
				.findAgreementStatusAndReason(agreementNumber,
						PropertyKindType.StatusReason.getPropertyKind());

		if (agreementStatusAndStatusReasonFLO == null
				|| agreementStatusAndStatusReasonFLO.size() != 1
				|| agreementStatusAndStatusReasonFLO.get(0) == null) {
			/*
			 * Agreement status not found, return false.
			 */
			return false;
		} else {
			AgreementStatusAndStatusReasonFLO flo = agreementStatusAndStatusReasonFLO
					.get(0);
			/*
			 * An In-force agreement is one having status Active or [Retired
			 * with status reason Retired Active] Also ensure that the agreement
			 * belongs to the same division as the input kind
			 */
			if ((AgreementKindType.getAgreementKindType(flo.getKind())
					.getPrimaryAgreementDivisionType().equals(AgreementKindType
					.getAgreementKindType(kind)
					.getPrimaryAgreementDivisionType()))
					&& (flo.getStatusID() == AgreementStatusType.ACTIVE
							.getSpecId()
							|| flo.getStatusID() == AgreementStatusType.BROKER_ACTIVE
									.getSpecId() || ((flo.getStatusID() == AgreementStatusType.RETIRED
							.getSpecId() || flo.getStatusID() == AgreementStatusType.BROKER_RETIRED
							.getSpecId())
							&& flo.getStatusReason() != null && flo
							.getStatusReason().equals(
									AgreementStatusReasonType.RETIRED_ACTIVE
											.getDescription())))) {
				return true;
			}
		}

		return false;
	}

	/**
	 * This method analyzes if the input agreement flo is of an in-force
	 * agreement.
	 * 
	 * An in-force agreement is one with status "Active" or
	 * "Retired with status reason Retired-Active"
	 * 
	 */
	public boolean isAgreementInForce(
			List<AgreementStatusAndStatusReasonFLO> flos) {

		if (flos == null || flos.size() < 1) {
			return false;
		}
		for (AgreementStatusAndStatusReasonFLO flo : flos) {
			if (flo.getStatusID() == AgreementStatusType.ACTIVE.getSpecId()
					|| flo.getStatusID() == AgreementStatusType.BROKER_ACTIVE
							.getSpecId()
					|| ((flo.getStatusID() == AgreementStatusType.RETIRED
							.getSpecId() || flo.getStatusID() == AgreementStatusType.BROKER_RETIRED
							.getSpecId())
							&& flo.getStatusReason() != null && flo
							.getStatusReason().equals(
									AgreementStatusReasonType.RETIRED_ACTIVE
											.getDescription()))) {
				return true;
			}
		}

		return false;
	}

	private AgreementDTO isPrimaryAgreement(AgreementDTO agreementDTO,
			long currentAgmtNumber, List<Long> agmtNumbers) {

		Date currentAgmtEndDate = null;
		boolean setCurrAgmtAsPrim = true;

		/* Get the end date for the input agreement numbers */
		List<AgreementStatusAndStatusReasonFLO> agreementStatusAndStatusReasonFLO = agreementEntityManager
				.findAgreementEndDate(agmtNumbers);
		for (AgreementStatusAndStatusReasonFLO flo : agreementStatusAndStatusReasonFLO) {
			if (flo != null && flo.getAgreementNumber() != null
					&& currentAgmtEndDate == null
					&& flo.getAgreementNumber().equals(currentAgmtNumber)) {
				currentAgmtEndDate = flo.getEndDate();
			}
		}

		if (agreementStatusAndStatusReasonFLO != null) {
			for (AgreementStatusAndStatusReasonFLO flo : agreementStatusAndStatusReasonFLO) {
				if (flo != null
						&& flo.getAgreementNumber() != null
						&& (!flo.getAgreementNumber().equals(currentAgmtNumber))) {
					Date otherAgmtEndDate = flo.getEndDate();
					if (currentAgmtEndDate != null && otherAgmtEndDate != null
							&& otherAgmtEndDate.after(currentAgmtEndDate)) {
						setCurrAgmtAsPrim = false;
					}
				}

			}
		}
		// MZL2611 added to is primary agreement Soloh-CatchUp
		PrimaryAgreementDTO primaryAgmDTO = determineContextPartiesPrimaryAgmtSOLOHCatchUP(agreementDTO
				.getPartyOid().longValue());

		agreementDTO.setPrimaryAgreementDTO(primaryAgmDTO);

		// MZL2611 added to is primary agreement Soloh-CatchUp

		if (setCurrAgmtAsPrim) {
			/*
			 * If the context Agreement is the latest out of force agreement
			 */
			agreementDTO.setPrimaryAgreement(true);
			agreementDTO.setPrimaryAgreementForced(true);
			return agreementDTO;
		} else {
			/*
			 * If the context agreement is not the latest out of force agreement
			 */
			agreementDTO.setPrimaryAgreement(false);
			agreementDTO.setPrimaryAgreementForced(true);
			return agreementDTO;
		}
	}
	
	
	
//	public boolean fetchPaySchedHistoryTempProp(long agreemnetNumber, int kind){
//		/* Get the status and status reason value for the input agreement number */
//		List<AgreementStatusAndStatusReasonFLO> agreementStatusAndStatusReasonFLO = agreementEntityManager
//				.findAgreementStatusAndReason(agreemnetNumber,
//						PropertyKindType.StatusReason.getPropertyKind());
//		
//		
//		return false;
//		
//	}

	/**
	 * This method analyzes if the input agreement number is of an in-force
	 * agreement.
	 * 
	 * An in-force agreement is one with status "Active" or
	 * "Retired with status reason Retired-Active"
	 * 
	 */
	public AgreementStatusAndStatusReasonFLO getAgreementStatusDetails(
			long agreementNumber) throws ValidationException {

		/* Get the status and status reason value for the input agreement number */
		List<AgreementStatusAndStatusReasonFLO> agreementStatusAndStatusReasonFLO = agreementEntityManager
				.findAgreementStatusAndReason(agreementNumber,
						PropertyKindType.StatusReason.getPropertyKind());

		if (agreementStatusAndStatusReasonFLO == null
				|| agreementStatusAndStatusReasonFLO.size() != 1
				|| agreementStatusAndStatusReasonFLO.get(0) == null) {
			/*
			 * Agreement status not found, return false.
			 */
			return null;
		} else {
			return agreementStatusAndStatusReasonFLO.get(0);

		}
	}

	private List<AgreementStatusAndStatusReasonFLO> getAgreementsInPartyAndKind(
			List<Long> agreementNumbers, long currentAgmtNo, int currentKind) {
		List<AgreementStatusAndStatusReasonFLO> finalFlo = new ArrayList<AgreementStatusAndStatusReasonFLO>();

		for (Long agmtNumber : agreementNumbers) {
			if (agmtNumber != null && agmtNumber.equals(currentAgmtNo)) {
				continue;
			}
			List<AgreementStatusAndStatusReasonFLO> agreementStatusAndStatusReasonFLO = agreementEntityManager
					.findAgreementStatusAndReason(agmtNumber,
							PropertyKindType.StatusReason.getPropertyKind());

			if (agreementStatusAndStatusReasonFLO == null
					|| agreementStatusAndStatusReasonFLO.size() != 1
					|| agreementStatusAndStatusReasonFLO.get(0) == null) {
				continue;
			} else {
				AgreementStatusAndStatusReasonFLO flo = agreementStatusAndStatusReasonFLO
						.get(0);
				/*
				 * An In-force agreement is one having status Active or [Retired
				 * with status reason Retired Active] Also ensure that the
				 * agreement belongs to the same division as the input kind
				 */

				if (AgreementKindType
						.getAgreementKindType(flo.getKind())
						.getPrimaryAgreementDivisionType()
						.equals(AgreementKindType.getAgreementKindType(
								currentKind).getPrimaryAgreementDivisionType())) {
					finalFlo.add(flo);
				}
			}

		}

		return finalFlo;
	}

	/**
	 * This method returns the PrimaryAgreement map object for the provided
	 * party objectID. The map is of the following constitution: Key -
	 * division/kind value - agreement number
	 */
	public Map<Long, Long> getPrimaryAgreementMap(long partyOid)
			throws ValidationException {
		return agreementValidator.getPrimaryAgreementMap(partyOid);
	}

	public Map<Long, Long> getPrimaryAgreementMap() throws ValidationException {
		return primaryAgreementMap;
	}

	public long getCurrPrimaryAgreementNumber() {
		return currentPrimaryAgmtNumber;
	}

	public void setCurrPrimaryAgreementNumber(long currentPrimaryAgmtNumber) {
		this.currentPrimaryAgmtNumber = currentPrimaryAgmtNumber;
	}

	public void setPrimaryAgreementMap(Map<Long, Long> primaryAgreementMap)
			throws ValidationException {
		primaryAgreementMap = primaryAgreementMap;
	}

	/**
	 * 
	 * This method returns true if the context agreement is in the status
	 * "InProgress" or "Declined".
	 */
	public boolean isContextAgreementInProgressOrDeclined(
			AgreementDTO initialContext) {
		return initialContext != null
				&& initialContext.getCurrentStatus() != null
				&& initialContext.getCurrentStatus().getName() != null
				&& (initialContext.getCurrentStatus().getName()
						.equalsIgnoreCase("InProgress") || initialContext
						.getCurrentStatus().getName()
						.equalsIgnoreCase("Declined"));
	}

	// SSM2707 Added for Hierarchy FR3.5 Primary Agreement SWETA MENON End
	// SSM2707 Hierarchy FR3.4 FAIS Details SWETA MENON Begin
	/**
	 * This method is used to compare the MaintainAgreementDTO objects [before
	 * and after maintenance] to check if any of the change requires an
	 * information message to be displayed on the target panel.
	 */
	private void checkForInfoMessages(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {

		/* Check for Sales Category change for FAIS Details message Begin */
		if (previousMaintainAgreementDTO != null
				&& previousMaintainAgreementDTO.getAgreementDTO() != null
				&& maintainAgreementDTO != null
				&& maintainAgreementDTO.getAgreementDTO() != null
				&& maintainAgreementDTO.getAgreementDTO().getSalesCategory() != null) {

			String previousSalesCat = previousMaintainAgreementDTO
					.getAgreementDTO().getSalesCategory();
			String newSalesCat = maintainAgreementDTO.getAgreementDTO()
					.getSalesCategory();

			if (previousSalesCat == null
					|| (!previousSalesCat.equals(newSalesCat)
							&& getSalesCategoryWithoutFAIS().contains(
									previousSalesCat) && !getSalesCategoryWithoutFAIS()
							.contains(newSalesCat))) {
				// Old Sales category did not require FAIS. The new one does.
				addToInfoMessageList("Please ensure this agreement’s FAIS categories are set correctly or the adviser will not be able to capture new business.");
			}
		}
		/* Check for Sales Category change for FAIS Details message End */
	}

	/**
	 * The method is used to get the list of information messages to be
	 * displayed on the target panel.
	 */
	public List<String> getInfoMessageList() {
		return infoMessageList;
	}

	/**
	 * The method is used to set the list of information messages to be
	 * displayed on the target panel.
	 */
	public void setInfoMessageList(List<String> messageList) {
		infoMessageList = messageList;
	}

	/**
	 * The method is used to add a message to the list of information messages
	 * to be displayed on the target panel.
	 */
	public void addToInfoMessageList(String message) {
		infoMessageList.add(message);
	}

	/**
	 * The method is used to add a message to the list of information messages
	 * to be displayed on the target panel.
	 */
	public void clearInfoMessageList() {
		if (infoMessageList != null && infoMessageList.size() > 0) {
			infoMessageList.clear();
		}
	}

	/**
	 * Get all the property values since 2010
	 */
	public List<TemporalPropertyFLO> getHistoricLinkedMedicalDetails(long agreementNr) {
		// TODO Auto-generated method stub
		return agreementEntityManager
				.getAgreementPropertyFLOListOfKind(PropertyKindType.HasMedicalAidTaxCredits, 
						agreementNr, new Date(), DateUtil.getDate("2010-01-01"));
	}

	// SSM2707 Hierarchy FR3.4 FAIS Details SWETA MENON End

	// MZL2611 SIMS SOLOH Catch-UP Begin
	/**
	 * Check for Broker Division
	 * 
	 * @param agreementId
	 * @param partyId
	 * @param contextDTO
	 * @return
	 */
	public boolean isBrokerDivision(int kind) {
		if (AgreementKindType.getAgreementKindType(kind)
				.getPrimaryAgreementDivisionType().getKind() == PrimaryAgreementDivisionType.BROKER
				.getKind()) {

			return true;
		}
		return false;
	}

	public List<AgreementStatusAndStatusReasonFLO> findOtherAgreements(
			long partyId) {
		List<Long> partyAgreementNumbers = entityManager
				.findAllAgreementsLinkedToParty(partyId);
		List<AgreementStatusAndStatusReasonFLO> finalFlo = new ArrayList<AgreementStatusAndStatusReasonFLO>();
		for (Long agmtNumber : partyAgreementNumbers) {

			List<AgreementStatusAndStatusReasonFLO> agreementStatusAndStatusReasonFLO = agreementEntityManager
					.findAgreementStatusAndReason(agmtNumber,
							PropertyKindType.StatusReason.getPropertyKind());

			if (agreementStatusAndStatusReasonFLO == null
					|| agreementStatusAndStatusReasonFLO.size() != 1
					|| agreementStatusAndStatusReasonFLO.get(0) == null) {
				continue;
			} else {
				AgreementStatusAndStatusReasonFLO flo = agreementStatusAndStatusReasonFLO
						.get(0);
				finalFlo.add(flo);
			}
		}
		return finalFlo;
	}

	/**
	 * SOLOH Catch-UP Primary agreement if context party has Broker agreement is
	 * inforce and STOP ORDER Agreement set the Broker agreement to Primary
	 * Agreement
	 * 
	 * @param agreementId
	 * @param partyId
	 * @return
	 */
	public PrimaryAgreementDTO determineContextPartiesPrimaryAgmtSOLOHCatchUP(
			long partyId) {
		boolean isInforce = false;
		PrimaryAgreementDTO agreementHolderObject = new PrimaryAgreementDTO();
		// get agreements for party
		List<AgreementStatusAndStatusReasonFLO> findOtherAgreements = findOtherAgreements(partyId);
		// check for Broker Agreement
		for (AgreementStatusAndStatusReasonFLO agreementStatusAndStatusReasonFLO : findOtherAgreements) {
			// check if broker agreement
			if (AgreementKindType
					.getAgreementKindType(agreementStatusAndStatusReasonFLO
							.getKind()) == AgreementKindType.BROKER) {
				// check if broker division
				if (isBrokerDivision(agreementStatusAndStatusReasonFLO
						.getKind())) {
					// check if inforce
					isInforce = isAgreementInForce(
							agreementStatusAndStatusReasonFLO
									.getAgreementNumber(),
							agreementStatusAndStatusReasonFLO.getKind());
					agreementHolderObject
							.setAgreementID(agreementStatusAndStatusReasonFLO
									.getAgreementNumber());
					agreementHolderObject.setPrimaryAgreement(isInforce);
					agreementHolderObject
							.setKind(agreementStatusAndStatusReasonFLO
									.getKind());
					break;
				}
			}
		}

		if (isInforce) {
			return agreementHolderObject;
		}

		// check for Stop Order Agreement
		for (AgreementStatusAndStatusReasonFLO agreementStatusAndStatusReasonFLO : findOtherAgreements) {
			// check if the agreement is of kind STOP Order
			if (AgreementKindType
					.getAgreementKindType(agreementStatusAndStatusReasonFLO
							.getKind()) == AgreementKindType.STOP_ORDER_BROKER) {
				// check if broker division
				if (isBrokerDivision(agreementStatusAndStatusReasonFLO
						.getKind())) {
					// check if inforce
					isInforce = isAgreementInForce(
							agreementStatusAndStatusReasonFLO
									.getAgreementNumber(),
							agreementStatusAndStatusReasonFLO.getKind());
					agreementHolderObject
							.setAgreementID(agreementStatusAndStatusReasonFLO
									.getAgreementNumber());
					agreementHolderObject.setPrimaryAgreement(isInforce);
					agreementHolderObject
							.setKind(agreementStatusAndStatusReasonFLO
									.getKind());
					break;

				}
			}
		}

		return agreementHolderObject;
	}

	// SSM2707 Added for Hierarchy FR3.5 Primary Agreement SWETA MENON Begin
	/* Market Integration Sweta Menon SSM2707 1st April 2016 */
	public void validateOldSalesCategoryForServPanel(String newSalesCat,
			String prevSalesCat, long partyOid) throws ValidationException {
		if ((prevSalesCat != null && newSalesCat != null)
				&& (!prevSalesCat.equals(newSalesCat))) {
			/* Entering this loop indicates the sales category has changed. */
			/*
			 * Identify if the previous sales category is of a type that can
			 * have a Sales/Support panel
			 */
			List<String> bcSalesCategories = ratingEntityManager
					.getBCSalesCatAllowed();

			/* If the previous Sales category is that of a BC */
			if (bcSalesCategories.contains(prevSalesCat)) {
				/*
				 * Identify is the BC has a panel. If yes, check if the panel
				 * status is Active. If the panel status is other than active
				 * (pending termination or terminated, the sales category can be
				 * modified.
				 */
				List<PanelDetailFLO> panelInfos = entityManager
						.getPanelDetailsFromConsultant(partyOid);
				
				if (panelInfos != null && panelInfos.size() > 0) {
					for (PanelDetailFLO panelInfo : panelInfos) {
						if (panelInfo != null
								&& panelInfo.getStatusCode() == PartyStatusType.ACTIVE
										.getStatusCode()) {
							throw new ValidationException(
									"This agreement has a Servicing Panel. Sales Category cannot be modified.");
						}
					}

				}

				

			}
		}
	}

	public void validateNewSalesCategoryForServPanel(String newSalesCat,
			String prevSalesCat, long partyOid)
			throws ValidationException {
		if ((prevSalesCat != null && newSalesCat != null)
				&& (!prevSalesCat.equals(newSalesCat)) || (prevSalesCat == null && newSalesCat != null)) {
			/* Entering this loop indicates the sales category has changed. */
			/*
			 * Identify if the previous sales category is of a type that can
			 * have a Sales/Support panel
			 */
			List<String> bcSalesCategories = ratingEntityManager
					.getBCSalesCatAllowed();

			if (bcSalesCategories.contains(newSalesCat)) {
				/*
				 * Do not allow the change as the new Sales Category requires a
				 * panel
				 */
				throw new ValidationException(
						"The chosen Sales category requires Servcing Panel creation. Sales Category cannot be modified to "
								+ newSalesCat + ".");
			} else if (!bcSalesCategories.contains(newSalesCat)) {
				/*
				 * Identify is the BC has a panel. If yes, check if the panel
				 * status is Active. If the panel status is other than active
				 * (pending termination or terminated, the sales category can be
				 * modified.
				 */
				
				List<PanelDetailFLO> panelInfos = entityManager
						.getPanelDetailsFromConsultant(partyOid);
				
				if (panelInfos != null && panelInfos.size() > 0) {
					for (PanelDetailFLO panelInfo : panelInfos) {
						if (panelInfo != null
								&& panelInfo.getStatusCode() == PartyStatusType.ACTIVE
										.getStatusCode()) {
							throw new ValidationException(
									"This agreement has a Servicing Panel. Sales Category cannot be modified.");
						}
					}

				}
				
			}

		}
	}

	public void validateSalesCategoryForServByPanel(String newSalesCat,
			String prevSalesCat, long partyOid) throws ValidationException {
		if ((prevSalesCat != null && newSalesCat != null)
				&& (!prevSalesCat.equals(newSalesCat))
				|| (prevSalesCat == null && newSalesCat != null)) {
			/*
			 * If the previous Sales category is that of an Adviser and the new
			 * sales category is not
			 */
			List<String> adviserSalesCategories = ratingEntityManager
					.getAdviserLinkingSalesCatAllowed();
			if ((adviserSalesCategories.contains(prevSalesCat) && (!adviserSalesCategories
					.contains(newSalesCat)))
					|| (!adviserSalesCategories.contains(prevSalesCat) && (adviserSalesCategories
							.contains(newSalesCat)))
					|| (prevSalesCat == null && (!adviserSalesCategories
							.contains(newSalesCat)))) {
				/* Check if the agreement is linked to a servicing panel */
				List<PanelDetailFLO> panels = getAdviserPanels(partyOid);

				if (panels != null && panels.size() > 0) {
					/*
					 * Do not allow the change as the new Sales Category
					 * requires a panel
					 */
					throw new ValidationException(
							"The agreement is linked to a Servicing Panel. Sales Category cannot be modified.");
				}
			}

		}
	}

	private List<PanelDetailFLO> getAdviserPanels(long advPartyOID) {
		List<PanelDetailFLO> panels = partyEntityManager
				.getConsultantDetailsFromAdviserParty(advPartyOID,
						SRSType.ISSERVICEDBYPANEL,
						SRSType.ISSERVICINGCONSULTANTOF);
		return panels;
	}
	
	/* Market Integration Sweta Menon SSM2707 1st April 2016 End */
	// SSM2707 SWETA MENON Agency Pool 11/10/2017 Begin 
	/**
	 * Compare the before and after MaintainAgreementDTO image to determine if
	 * SetOverrideIntoPoolRate request should be raised
	 * 
	 * @param maintainAgreementDTO
	 * @param previousMaintainAgreementDTO
	 * @return
	 */
	private boolean isSetOverrideIntoPoolRateRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO()
						.getAgencyPoolAccountDetailDTO() == null
				|| maintainAgreementDTO.getAgreementDTO()
						.getAgencyPoolAccountDetailDTO()
						.getFutureOverrideIntoAgencyPoolRate() == null) {
			return false;
		}
		if (previousMaintainAgreementDTO == null
				|| previousMaintainAgreementDTO.getAgreementDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getAgencyPoolAccountDetailDTO() == null
				|| previousMaintainAgreementDTO.getAgreementDTO()
						.getAgencyPoolAccountDetailDTO()
						.getFutureOverrideIntoAgencyPoolRate() == null) {
			return true;
		}
		return (ComparatorUtil.compareObjects(
				maintainAgreementDTO.getAgreementDTO()
						.getAgencyPoolAccountDetailDTO()
						.getFutureOverrideIntoAgencyPoolRate(),
				previousMaintainAgreementDTO.getAgreementDTO()
						.getAgencyPoolAccountDetailDTO()
						.getFutureOverrideIntoAgencyPoolRate(), true).size() != 0);
	}

	private boolean isAdhocAgencyPoolDrawRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {
		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO()
						.getAgencyPoolAccountDetailDTO() == null
				|| maintainAgreementDTO.getAgreementDTO()
						.getAgencyPoolAccountDetailDTO().getPoolDrawOption() == null) {
			return false;
		}

		// If the Pool Draw Option is modified, raise a request
		String currentPooDrawOption = maintainAgreementDTO.getAgreementDTO()
				.getAgencyPoolAccountDetailDTO().getPoolDrawOption();
		String previousPooDrawOption = previousMaintainAgreementDTO
				.getAgreementDTO().getAgencyPoolAccountDetailDTO()
				.getPoolDrawOption();
		
		if (currentPooDrawOption==null ) {
			return false;
		}
		
		if (previousPooDrawOption==null && currentPooDrawOption!=null ) {
			return true;
		}
		
		

		if (currentPooDrawOption.compareTo(previousPooDrawOption) != 0) {
			return true;
		}

		if (currentPooDrawOption != null
				&& currentPooDrawOption
						.equals(PoolDrawOptionsEnum.PERCENTAGE_OF_BALANCE
								.getValue())) {
			// If the Pool Draw Rate Selected is modified, raise the request
			Percentage currentPooDrawRateSelected = maintainAgreementDTO
					.getAgreementDTO().getAgencyPoolAccountDetailDTO()
					.getPoolDrawRateSelected();
			Percentage previousPooDrawRateSelected = previousMaintainAgreementDTO
					.getAgreementDTO().getAgencyPoolAccountDetailDTO()
					.getPoolDrawRateSelected();

			if (currentPooDrawRateSelected != null
					&& previousPooDrawRateSelected == null) {
				return true;
			}

			if (currentPooDrawRateSelected != null
					&& currentPooDrawRateSelected.getValue().compareTo(
							previousPooDrawRateSelected.getValue()) != 0) {
				return true;
			}
		}

		if (currentPooDrawOption != null
				&& currentPooDrawOption
						.equals(PoolDrawOptionsEnum.SPECIFIC_RAND_AMOUNT
								.getValue())) {
			// If the Requested Payment Amount is modified, raise the request
			CurrencyAmount currentPaymentAmount = maintainAgreementDTO
					.getAgreementDTO().getAgencyPoolAccountDetailDTO()
					.getRequestedPaymentAmount();
			CurrencyAmount previousPaymentAmount = previousMaintainAgreementDTO
					.getAgreementDTO().getAgencyPoolAccountDetailDTO()
					.getRequestedPaymentAmount();

			if (currentPaymentAmount != null && previousPaymentAmount == null) {
				return true;
			}

			if (currentPaymentAmount != null
					&& currentPaymentAmount.getValue().compareTo(
							previousPaymentAmount.getValue()) != 0) {
				return true;
			}
		}

		return false;
	}
	
	private boolean isStopAgencyPoolTransferRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {

		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO()
						.getAgencyPoolAccountDetailDTO() == null
				|| maintainAgreementDTO.getAgreementDTO()
						.getAgencyPoolAccountDetailDTO()
						.getStopIntoPoolTransfers() == null) {
			return false;
		}
		Boolean currentValue = maintainAgreementDTO.getAgreementDTO()
				.getAgencyPoolAccountDetailDTO().getStopIntoPoolTransfers();
		Boolean previousValue = previousMaintainAgreementDTO.getAgreementDTO()
				.getAgencyPoolAccountDetailDTO().getStopIntoPoolTransfers();

		if ((currentValue == null || currentValue.equals(Boolean.FALSE))
				&& (previousValue == null || previousValue
						.equals(Boolean.FALSE))) {
			return false;
		}
		if (!currentValue.equals(previousValue)) {
			return true;
		} else {
			return false;
		}
	}
	
	private boolean isCloseAgencyPoolRequestAllowed(
			MaintainAgreementDTO maintainAgreementDTO,
			MaintainAgreementDTO previousMaintainAgreementDTO) {

		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO()
						.getAgencyPoolAccountDetailDTO() == null
				|| maintainAgreementDTO.getAgreementDTO()
						.getAgencyPoolAccountDetailDTO().getCloseAgencyPool() == null) {
			return false;
		}
		Boolean currentValue = maintainAgreementDTO.getAgreementDTO()
				.getAgencyPoolAccountDetailDTO().getCloseAgencyPool();
		Boolean previousValue = previousMaintainAgreementDTO.getAgreementDTO()
				.getAgencyPoolAccountDetailDTO().getCloseAgencyPool();

		if ((currentValue == null || currentValue.equals(Boolean.FALSE))
				&& (previousValue == null || previousValue
						.equals(Boolean.FALSE))) {
			return false;
		}
		if (!currentValue.equals(previousValue)) {
			return true;
		} else {
			return false;
		}
	}
	
	private boolean isMaintainProvidentBeneficiariesRequestAllowed(MaintainAgreementDTO maintainAgreementDTO, MaintainAgreementDTO previousMaintainAgreementDTO) {

		if (maintainAgreementDTO == null
				|| maintainAgreementDTO.getAgreementDTO() == null
				|| maintainAgreementDTO.getAgreementDTO().getProvidentFundBeneficiariesDTO() == null
				|| maintainAgreementDTO.getAgreementDTO().getProvidentFundBeneficiariesDTO().getProvidentFundBeneficiaryDetailsList() == null) {
			return false;
		}
		ProvidentFundBeneficiariesDTO currentValue = maintainAgreementDTO.getAgreementDTO().getProvidentFundBeneficiariesDTO();
		ProvidentFundBeneficiariesDTO previousValue = previousMaintainAgreementDTO.getAgreementDTO().getProvidentFundBeneficiariesDTO();

		if ((currentValue == null ) && (previousValue == null)) {
			return false;
		}
		if (!currentValue.equals(previousValue)) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Method to check if there have been more than 2 Adhoc agency pool draws.
	 * The Adhoc Agency Pool draw request within the current Liberty tax year
	 * range is queried. If the returned result list has more than 2 items, it
	 * is inferred that there have been more than 2 adhoc draws.
	 */
	public boolean hasPoolDraw(long agreementNo) {
		DateRange lastTaxDateRange = getLibertyTaxYearDateRange();
		List<IRequestEnquiryRow> requestList = agreementManagement
				.findRequests(agreementNo, RequestKindType.AdhocAgencyPoolDraw,
						lastTaxDateRange.getStartDate(),
						lastTaxDateRange.getEndDate(), null,
						RequestStatusType.EXECUTED, RequestDateType.EXECUTED,
						1, 4);

		if (requestList == null || requestList.size() < 2) {
			return false;
		}

		return true;
	}
	
	
	/**
	 * Get the tax year end date for the previous tax year. 1 year is subtracted
	 * from the current date to get the previous year tax start and end date
	 */
	private DateRange getLibertyTaxYearDateRange() {
		GregorianCalendar gc = new GregorianCalendar();
		Date result = gc.getTime();

		DateRange range = ratingEntityManager.getTaxYearDates(result,
				TaxBasisConstants.TAX_YEAR_LIBERTY);

		
		return range;
	}
	/**
	 * Method to check if the agreement number has an active AgencyPoolAccount
	 * role. If the role exists, it is concluded that the agreement has an
	 * Agency Pool Account.
	 */
	public boolean hasAgencyPoolAccount(long agreementNo) {
		List<Long> rolePlayerIdList = new ArrayList<Long>();
		rolePlayerIdList.add(agreementNo);

		List<AgreementRoleDTO> agreementDetailList = agreementEntityManager
				.findAgreementRolesOfTypeForAgreements(rolePlayerIdList,
						RoleKindType.AGENCYPOOLACCOUNT, AgreementRoleDTO.class,
						true);

		if (agreementDetailList == null || agreementDetailList.size() <= 0) {
			return false;
		} else {
			return true;
		}

	}
	
	/**
	 * Method to check if the agreement number has an active Agency Pool
	 * Account. Check if the Close Agency Pool account indicator is 'true'
	 */
	public boolean isAgencyPoolClosed(long agreementNo) {

		Boolean closeAgnecyPoolInd = (Boolean) agreementEntityManager
				.getAgreementPropertyOfKind(
						PropertyKindType.CloseAgencyPoolInd, agreementNo);

		if (closeAgnecyPoolInd == null) {
			return false;
		}

		return closeAgnecyPoolInd;

	}
	
	/**
	 * Get the valid month start/month end dates. An indicator is passed as an
	 * input. Indicator value 0 represents month start and indicator value 1
	 * represents month end. The start date is usually the current date. A
	 * maximum of 12 start/end dates are returned. The values are collected for
	 * the current and the next year to get the list of return values.
	 * 
	 * 
	 */
	public List<Date> getLibertyMonthDatesForCurrentYear(Date startDate,
			Date endDate, int rowCount, int indicator) {
		/*
		 * Get month end dates
		 */
		List<CalculationDateFLO> ciDates = calculationDateEntityManager
				.findFastLaneCalculationDatesForPeriod(CIDateType.SRS_MONTHLY,
						startDate, endDate);

		List<Date> responseList = new ArrayList<Date>();
		for (CalculationDateFLO datesFlo : ciDates) {
			if (indicator == 0) {
				responseList.add(datesFlo.getFirstDayOf());
			} else if (indicator == 1) {
				responseList.add(datesFlo.getLastDayOf());
			}

		}

		// Sort the list in the ascending order
		Collections.sort(responseList);

		if (responseList.size() > rowCount) {
			return responseList.subList(0, rowCount - 1);
		} else {
			return responseList;
		}
	}
	
	/**
	 * 
	 */
	public boolean canUserTransferMaxPoolBalance(ISessionUserProfile userProfile){
		
		return securityManagement.canUserTransferMaxPoolBalance(userProfile);
	}
	
	
	/**
	 * GEt the valid Month Start/MonthEnd date for the next moth month. Indicator value 0 represents month start and indicator value 1
	 * represents month end. The start date is usually the current date and the
	 * end date is the 31st Dec of the current year.
	 */
	public Date getNextLibertyMonthDates(int indicator) {
		/*
		 * Get month end dates
		 */
		Date startDate = new Date();
		Date endDate = new Date();
		Date returnDate = null;
		CalculationDateFLO flo;

		List<CalculationDateFLO> ciDates;

		ciDates = calculationDateEntityManager
				.findFastLaneCalculationDatesForPeriod(CIDateType.SRS_MONTHLY,
						startDate, endDate);

		if (ciDates == null || ciDates.size() < 1) {
			return returnDate;
		}

		flo = ciDates.get(0);

		if (flo.getFirstDayOf() != null
				&& flo.getFirstDayOf().compareTo(startDate) < 0) {

			Calendar c = Calendar.getInstance();
			c.setTime(new Date());
			c.add(Calendar.MONTH, 1);

			startDate = c.getTime();
			endDate = c.getTime();

			ciDates = calculationDateEntityManager
					.findFastLaneCalculationDatesForPeriod(
							CIDateType.SRS_MONTHLY, startDate, endDate);

			if (ciDates == null || ciDates.size() != 1) {
				return returnDate;
			}

			flo = ciDates.get(0);
		}else if (flo.getFirstDayOf() != null
				&& flo.getFirstDayOf().compareTo(startDate) == 0) {

			Calendar c = Calendar.getInstance();
			c.setTime(new Date());
			c.add(Calendar.DATE, 1);

			startDate = c.getTime();
			endDate = c.getTime();

			ciDates = calculationDateEntityManager
					.findFastLaneCalculationDatesForPeriod(
							CIDateType.SRS_MONTHLY, startDate, endDate);

			if (ciDates == null || ciDates.size() != 1) {
				return returnDate;
			}

			flo = ciDates.get(0);

		}

		if (indicator == 0) {
			returnDate = flo.getFirstDayOf();
		} else if (indicator == 1) {
			returnDate = flo.getLastDayOf();
		}

		return returnDate;
	}
	/* SSM2707 Sweta Menon Agency Pool 10/10/2017 End */
	

	/**
	 * 
	 * @param agreementId
	 * @param partyId
	 * @return
	 */
	public boolean stopOrderBrokerAgmntPrimary(long agreementId, long partyId) {
		return true;
	}

	/**
	 * 
	 * @param agreementId
	 * @param partyId
	 * @return
	 */
	public boolean isInforce(long agreementId, long partyId) {
		return true;
	}

	// MZL2611 End

	public void validateSolohCatchUpAgreementTyping(AgreementDTO agreement)
			throws ValidationException {
		agreementValidator.validateSolohCatchUpAgreementTyping(agreement);

	}
	//pzm2509
    
	//Pzm2509 added for AML
	/**
	 * This method is for fetching data in the database that will be displayed
	 * within the Do Not Pay History panel
	 * 
	 */
	public List<PaymentSchedulerDTO> getPaySchedHistoryDataList(long agreementnumber,
			Date effectiveFromDate, Date effectiveToDate) {
		
		long actualRoleID;
		List<Long> agmNos = new ArrayList<Long>();
		agmNos.add(agreementnumber);
		List<AgreementRoleDTO> paySchedDNPRoleList = agreementEntityManager
				.findAgreementRolesOfTypeForAgreements(
						agmNos, RoleKindType.PAYMENTSCHEDULER, AgreementRoleDTO.class, true);
		if (paySchedDNPRoleList != null
				&& !paySchedDNPRoleList.isEmpty()) {
			AgreementRoleDTO agreementRoleDTO = (AgreementRoleDTO) paySchedDNPRoleList.get(0);	
			actualRoleID = agreementRoleDTO.getRoleID();
		} else {
			return new ArrayList<PaymentSchedulerDTO>();
		}
		

		List<TemporalPropertyFLO> paySchedDNPTempProp = agreementEntityManager
				.getAgreementPropertyFLOListOfKind(
						PropertyKindType.PaySchedDoNotPay, actualRoleID,
						effectiveFromDate, effectiveToDate, false);
		
		List<TemporalPropertyFLO> paySchedCommentTempProp = agreementEntityManager
				.getAgreementPropertyFLOListOfKind(
						PropertyKindType.PaySchedComment, actualRoleID,
						effectiveFromDate, effectiveToDate, false);

		List<TemporalPropertyFLO> paySchedRequesterTempProp = agreementEntityManager
				.getAgreementPropertyFLOListOfKind(
						PropertyKindType.PaySchedRequester, actualRoleID,
						effectiveFromDate, effectiveToDate, false);

		// Create the dto object with the do not pay, comment and requestor
		// history data.
		List<PaymentSchedulerDTO> dtoList = new ArrayList<PaymentSchedulerDTO>();
		for (TemporalPropertyFLO dnpIndFlo : paySchedDNPTempProp) {
			PaymentSchedulerDTO dto = new PaymentSchedulerDTO();
			
			if (dnpIndFlo.getValue()== null) {
				continue;
			}
			
			dto.setDoNotPay((Integer) dnpIndFlo.getValue() == 0?false:true);
			
			dto.setHistoryEffectiveDate(dnpIndFlo.getEffectiveFrom());
			dto.setHistoryEndDate(dnpIndFlo.getEffectiveTo());

			for (TemporalPropertyFLO commentFlo : paySchedCommentTempProp) {
				if ((commentFlo.getEffectiveFrom() != null && commentFlo
						.getEffectiveFrom().compareTo(
								dnpIndFlo.getEffectiveFrom()) == 0)
						&& ((commentFlo.getEffectiveTo() != null && dnpIndFlo.getEffectiveTo() != null && commentFlo
								.getEffectiveTo().compareTo(
										dnpIndFlo.getEffectiveTo()) == 0) || (commentFlo
								.getEffectiveTo() == null && dnpIndFlo
								.getEffectiveTo() == null))) {

					if (commentFlo.getValue() != null) {
						dto.setComments((String) commentFlo.getValue());
					}

				}
			}
				//AML checking for nulls within the temporal table
			for (TemporalPropertyFLO requestedByFlo : paySchedRequesterTempProp) {
				if ((requestedByFlo.getEffectiveFrom() != null && requestedByFlo
						.getEffectiveFrom().compareTo(
								dnpIndFlo.getEffectiveFrom()) == 0)
						&& ((requestedByFlo.getEffectiveTo() != null
								&& dnpIndFlo.getEffectiveTo() != null && (requestedByFlo
								.getEffectiveTo().compareTo(
										dnpIndFlo.getEffectiveTo()) == 0))
						|| (requestedByFlo.getEffectiveTo() == null && dnpIndFlo
								.getEffectiveTo() == null))) {

					if (requestedByFlo.getValue() != null) {
						dto.setRequestedBy((String) requestedByFlo.getValue());
					}

				}
			}
			dtoList.add(dto);
			
		}

		
		// Sort the final list
		Collections.sort(dtoList,
				Collections.reverseOrder(new HistoryDateComparator()));
		return dtoList;
	}

	private class HistoryDateComparator implements
			Comparator<PaymentSchedulerDTO> {

		public int compare(PaymentSchedulerDTO o1,
				PaymentSchedulerDTO o2) {
			return DateUtil.compareDates(o1.getHistoryEffectiveDate(),
					o2.getHistoryEffectiveDate());
		}

	}
	public void setSupervision(final FAISLicensePanelGridDTO data) {

		long accumulatedExperience = 0;
		if (data != null && data.getFaisLicenseCategoryDTO() != null)
			accumulatedExperience = data.getCurrentExperience() + data.getFaisLicenseCategoryDTO().getPriorExperinceTotalMonths();

		// When Accumulated experience >= 72 months, do not create any supervision periods of any type (Direct or Ongoing) for this FAIS category.
		if (accumulatedExperience >= 72) {
			return;
		}

		FAISCategorySupervisionDTO categorySupervisionDTO = null;
		FAISSupervisionTypeDBEnumDTO directSupervisionEnumDTO = getFAISSupervisionType(1);// 1 is for Direct
		FAISSupervisionTypeDBEnumDTO ongoingSupervisionEnumDTO = getFAISSupervisionType(2);// 2 is for Ongoing

		Date categoryStartDate = data.getFaisLicenseCategoryDTO().getCategory_StartDate();
		Collection<FAISCategorySupervisionDTO> faisCategorySupervisionDTOList = data.getFaisLicenseCategoryDTO().getFaisCategorySupervisionDTO();

		long adjusted = 72 - accumulatedExperience;
		// Create a Direct supervision period with supervision start date equal
		// to category start date when Accumulated Experience is < 72 months
		if (accumulatedExperience < 72) {
			logger.info("Accumulated Experience less than 72 :" + accumulatedExperience);
			// Work out the Supervision end date
			Date directSupervisionEndDate = null;
			if (adjusted >= 4)
				directSupervisionEndDate = getSupervisionEndDate(categoryStartDate, 4);
			else if (adjusted < 4 && adjusted > 0)
				directSupervisionEndDate = getSupervisionEndDate(categoryStartDate, (int) adjusted);

			if (faisCategorySupervisionDTOList != null && !faisCategorySupervisionDTOList.isEmpty()) {
				for (FAISCategorySupervisionDTO supervisionDTO : faisCategorySupervisionDTOList) {
					if (supervisionDTO != null && directSupervisionEnumDTO != null) {
						if (directSupervisionEnumDTO.equals(supervisionDTO.getSupervisionTypeDBEnumDTO())) {
							if (supervisionDTO.getCreationTime() == null)
								supervisionDTO.setCreationTime(new Date());
							supervisionDTO.setCreatedBy("");
							supervisionDTO.setEffectiveFrom(categoryStartDate);
							supervisionDTO.setEffectiveTo(directSupervisionEndDate);
							supervisionDTO.setSupervisionTypeDBEnumDTO(directSupervisionEnumDTO);
						}
					}
				}
			} else {
				faisCategorySupervisionDTOList = new ArrayList<FAISCategorySupervisionDTO>();
				categorySupervisionDTO = createFaisCategorySupervisionDTO(categoryStartDate, directSupervisionEndDate, directSupervisionEnumDTO, data.getFaisLicenseCategoryDTO().getOid());
				faisCategorySupervisionDTOList.add(categorySupervisionDTO);
				data.getFaisLicenseCategoryDTO().setFaisCategorySupervisionDTO(faisCategorySupervisionDTOList);
			}

			/*
			 * Create an Ongoing supervision period with supervision start date
			 * equal to Direct supervision end date when n above is > 4
			 * 
			 * Set the Ongoing supervision period end date to ((Ongoing
			 * supervision start date derived in point 3 above) + (72 -
			 * (Accumulated Experience - Direct Supervision Period in months)))
			 */
			if (adjusted > 4) {
				int ongoingAdjusted = (int) (adjusted - getMonths(directSupervisionEndDate, categoryStartDate));
				Date ongoingSuperversionEndDate = getSupervisionEndDate(directSupervisionEndDate, ongoingAdjusted);
				boolean ongoingFound = false;
				if (faisCategorySupervisionDTOList != null && !faisCategorySupervisionDTOList.isEmpty()) {
					for (FAISCategorySupervisionDTO supervisionDTO : faisCategorySupervisionDTOList) {
						if (ongoingSupervisionEnumDTO != null && supervisionDTO != null) {
							if (ongoingSupervisionEnumDTO.equals(supervisionDTO.getSupervisionTypeDBEnumDTO())) {
								ongoingFound = true;
								if (supervisionDTO.getCreationTime() == null)
									supervisionDTO.setCreationTime(new Date());
								supervisionDTO.setCreatedBy("");
								supervisionDTO.setEffectiveFrom(directSupervisionEndDate);
								supervisionDTO.setEffectiveTo(ongoingSuperversionEndDate);
								supervisionDTO.setSupervisionTypeDBEnumDTO(ongoingSupervisionEnumDTO);
								break;
							}
						}
					}
				}
				if (!ongoingFound) {
					categorySupervisionDTO = createFaisCategorySupervisionDTO(directSupervisionEndDate, ongoingSuperversionEndDate, ongoingSupervisionEnumDTO, data.getFaisLicenseCategoryDTO().getOid());
					faisCategorySupervisionDTOList.add(categorySupervisionDTO);
					data.getFaisLicenseCategoryDTO().setFaisCategorySupervisionDTO(faisCategorySupervisionDTOList);
				}
			}

		}

	}

	private FAISCategorySupervisionDTO createFaisCategorySupervisionDTO(Date startDate, Date endDate, FAISSupervisionTypeDBEnumDTO supervisionEnumDTO, long faisCategoryid) {
		FAISCategorySupervisionDTO categorySupervisionDTO = null;
		if (startDate != null && supervisionEnumDTO != null) {
			categorySupervisionDTO = new FAISCategorySupervisionDTO();
			categorySupervisionDTO.setCreationTime(new Date());
			categorySupervisionDTO.setCreatedBy("");
			categorySupervisionDTO.setEffectiveFrom(startDate);
			categorySupervisionDTO.setEffectiveTo(endDate);
			categorySupervisionDTO.setFaisCategoryid(faisCategoryid);
			categorySupervisionDTO.setSupervisionTypeDBEnumDTO(supervisionEnumDTO);
		}

		return categorySupervisionDTO;
	}

	private FAISSupervisionTypeDBEnumDTO getFAISSupervisionType(int key) {
		List<FAISSupervisionTypeDBEnumDTO> supervisorType = DatabaseEnumHelper.getDatabaseDTO(FAISSupervisionTypeDBEnumDTO.class);
		for (FAISSupervisionTypeDBEnumDTO faisSupervisionTypeDBEnumDTO : supervisorType) {
			if (faisSupervisionTypeDBEnumDTO.getKeyInt() == key) {
				return faisSupervisionTypeDBEnumDTO;
			}
		}
		return null;
	}

	private Date getSupervisionEndDate(Date category_StartDate, int numberOfMonths) {
		Date supervisionEndDate = null;
		if (category_StartDate != null) {
			Calendar startDate = Calendar.getInstance();
			startDate.setTime(category_StartDate);
			startDate.add(Calendar.MONTH, numberOfMonths);

			supervisionEndDate = startDate.getTime();
		}
		return supervisionEndDate;
	}

	/**
	 * This method returns number of months difference between date1 and date2
	 * date2 being the least date and date1 being latest.
	 * 
	 * @param date1
	 * @param date2
	 * @return
	 */
	private long getMonths(Date date1, Date date2) {
		long months = 0;
		if (date1 != null && date2 != null) {
			Calendar cal1 = Calendar.getInstance();
			Calendar cal2 = Calendar.getInstance();

			cal1.setTime(date1);
			cal2.setTime(date2);
			months = cal1.get(Calendar.MONTH) - cal2.get(Calendar.MONTH);
			months = months + ((cal1.get(Calendar.YEAR) - cal2.get(Calendar.YEAR)) * 12);
		}
		return months;

	}
	
	/**
	 * Validate the Provident Fund Beneficiaries
	 * 
	 * @param agreementDTO
	 * @throws ValidationException
	 */
	@Override
	public void validateProvidentBeneficiaries(ProvidentFundBeneficiariesDTO providentFundBeneficiariesDTO) throws ValidationException {
		agreementValidator.validateProvidentBeneficiaries(providentFundBeneficiariesDTO);
	}

	
	
	/* PZM2509 AVS-R  Start*/
	
	/**
	 * Retrieve banking verification results with an agreement
	 * @param agreementNO
	 *  
	 *  
	 */

	@Override
	public List<BankingDetailsHistoryDTO> getBankingVerificationHistoryForAgreementNo(long agreementnumber) {
		

		Collection<PropertyKindType> bankVerificationProperties = Collections.EMPTY_LIST;
		
		
		List<BankingDetailsHistoryDTO> resulltDTO = null;
		
		if(requestKind == RequestKindType.MaintainPaymentDetails) {
			
			bankVerificationProperties = Arrays.asList(new PropertyKindType[] {
					PropertyKindType.IsAccountActive,PropertyKindType.IsAccountVerified,
					PropertyKindType.IsIdentityNumber,PropertyKindType.IsAccountAcceptDebits,
					PropertyKindType.IsAccountAcceptCredits,PropertyKindType.IsAccountThreeMonths,
					PropertyKindType.IsLastName});
			resulltDTO = agreementEntityManager.findBankingDetailsVerificationHistory(agreementnumber, BankingDetailsHistoryDTO.class);
		} else {
			resulltDTO = agreementEntityManager.findBankingDetailsVerificationHistory(agreementnumber, BankingDetailsHistoryDTO.class);
			
		}
		List<BankingDetailsHistoryDTO> returnList = resulltDTO.stream().map(dto -> {
			//using Lambda to pass through objects from agreementrole to getting the uafcID from the party using a FLO from findUacfIdForPartyOidList
			List<Long> oids = Arrays.asList(dto.getRequestorOID(), dto.getAuthoriserOID());
			List<PartyUacfIdFLO> uafcidList = entityManager.findUacfIdForPartyOidList(oids);
			uafcidList.forEach(id -> {
				if (dto.getRequestorOID() == id.getPartyOid())
					dto.setRequestorUACFID(id.getUacfId());
				if (dto.getAuthoriserOID() == id.getPartyOid())
					dto.setAuthoriserUACFID(id.getUacfId());
			});
			return dto;
		}).collect(Collectors.toList());

		return returnList;
	}

	
	/* PZM2509 AVS-R  End*/
		

	/*------------------------------------SBS0510--------------------------------------------------------------------------------*/	

	/**
	 * Get the mid six of the consultant code for the relevant anchor role.
	 * 
	 * @param agreementDTO context agreement to be sent
	 * @param agreementRoleDTO  relevant role for this kind of agreement
	 * return the MidSix linked to the anchor role used
	 * @throws ValidationException 
	 */
	public ConsCodeGenerationDTO getMidSixFromAnchor(AgreementDTO agreementDTO, AgreementRoleDTO agreementRoleDTO) throws ValidationException {
		// Retrieve the property from the belongs to agreement
		@SuppressWarnings("unchecked")
		IPropertyFLO<String> flo = (IPropertyFLO<String>) agreementManagement.getAgreementPropertyFLOOfKind(
				agreementRoleDTO.getRolePlayerReference().getOid(), PropertyKindType.OrganisationMidsix);
		
		if (flo == null || flo.getValue() == null || flo.getValue().length()!=6) {
			// For now we assume its broker as only broker is enabled, this must be updated for additional channels
			// TODO put this code back later, for now we are out of time and only splitting mid six from the conscode
			//      as well as doing some manual checks
//			throw new ValidationException("Unable to retrieve organisation mid Six from the belongs to agreement nr " 
//					+ agreementRoleDTO.getRolePlayerReference().getOid());
			
			// Confirm this is a broker agreement for an organisation and broker agreement
			ResultAgreementDTO result = (ResultAgreementDTO) agreementRoleDTO.getRolePlayerReference();
			if (result==null) {
				try {
					result = agreementManagement.findAgreementWithSRSAgreementNr(agreementRoleDTO.getRolePlayerReference().getOid());
				} catch (CommunicationException | DataNotFoundException e) {
					// Ignore
					logger.warn("Unable to find belongsTo agreement " + agreementRoleDTO.getRolePlayerReference().getOid() 
							+ " while trying to add a new broker agreement.");
					throw new ValidationException("Unable to find agreement details for " + agreementRoleDTO.getRolePlayerReference().getOid());
				}
			}	
			
			
			if (!AgreementKindType.isAutoGenConsCodeEnabled(result.getAgreementDivision().getKind())) {
				throw new ValidationException("BelongsTo agreement must be in the broker channel - " 
					+ agreementRoleDTO.getRolePlayerReference().getOid());
			}
			
			if (result.getConsultantCodeFormatted().length()!=13) {
				throw new ValidationException("Unable to retrieve mid six from belongsTo '" + result.getConsultantCodeFormatted() + "'");
			}
			String consCode = result.getConsultantCodeFormatted();
			String midSix = consCode.substring(3, 9);	
			
			flo = new PropertyFLO<String>();
			flo.setValue(midSix);
		}

		return new ConsCodeGenerationDTO(
				ConsCodeType.getMidSixTypeForAgreementKind(AgreementKindType.getAgreementKindType(agreementDTO.getKind())),
				flo.getValue(),null);
	}

	@Override
	public ConsCodeGenerationDTO getMidSix(AgreementDTO agreement, PartyType partyType) throws DataNotFoundException {
		throw new RuntimeException("method not done");
		//return consCodeManagement.getMidSix(agreement, partyType);

	}

	@Override
	public ConsCodeGenerationDTO getLastFour(AgreementDTO agreement, PartyType partyType,
			ConsCodeGenerationDTO midSixAnchor) throws DataNotFoundException {
	 	throw new RuntimeException("method not done");
		// return consCodeManagement.getLastFour(agreement, partyType, midSixAnchor);
	}	
	
	/**
	 * Release the last four of cons code
	 * 
	 * @param agreementDTO
	 * @throws DataNotFoundException 
	 */
	public void releaseLastFour(AgreementDTO agreementDTO) throws DataNotFoundException {
		 System.out.println("releaseLastFour");
	}

	/**
	 * Release mid six of cons code
	 * @param agreementDTO
	 * @throws DataNotFoundException 
	 */
	public void releaseMiddleSix(AgreementDTO agreementDTO) throws DataNotFoundException {
		consCodeManagement.releaseMiddleSix(agreementDTO);
	}
	
	
	/**
	 * Azure Defect fix - 196701
	 * Method to validate the Mid Six of Has Home and Belongs to for Broker or Report to for Agent etc are same 
	 * @param allCurrentRoles
	 * @throws ValidationException
	 */
	public void validateForMiddleSix(AgreementDTO agreementDto, ArrayList<AgreementRoleDTO> allCurrentRoles) throws ValidationException {

		if(CollectionUtils.isEmpty(allCurrentRoles))
			return;
		
		ArrayList<String> errors = new ArrayList<String>();
		
		RoleKindType roleKindType = getApplicableRoleKindTypeForAgmtKind(agreementDto.getKind());
		
		String hasHomeMidSix = null;
		String roleMidSix = null;
		
		
		for(AgreementRoleDTO agmRole:allCurrentRoles) {
			if(agmRole instanceof AgreementHomeRoleDTO) {
				AgreementHomeRoleDTO agreementHomeRoleDTO = (AgreementHomeRoleDTO)agmRole;
				hasHomeMidSix = agreementHomeRoleDTO.getMiddleSix();		//First get the Has Home Role
				
			} else {
				
				if(roleKindType.getKind() == agmRole.getKind()) {
					String consCode = ((ResultAgreementDTO)agmRole.getRolePlayerReference()).getConsultantCodeFormatted();					
					roleMidSix = consCode.substring(3, 9); // Then get the applicable role type like Belongs to role for Broker
				}		
			
			}
		}
		//Compare Has Home Mid Six and the Role Mid Six ie. Belongs To for Broker etc.
		
		if(StringUtils.isNotBlank(hasHomeMidSix) && StringUtils.isNotBlank(roleMidSix)) {
				
				if(!hasHomeMidSix.equalsIgnoreCase(roleMidSix)) {
					errors.add("The 'Middle Six' code for 'HasHome' do not match the '"+roleKindType.getDescription()+"' role !");
					errors.add("Remove the home role and add it again");
					throw new ValidationException(errors);
				}
				
		}			
		
	}	
	
	
	
	
	/**
	 * Get Applicable Role Kind Type for Agreement Kind .e.g. BELONGS TO for Brokers, ISMANAGEDBY for Franchise , etc.
	 * @param kind
	 * @return RoleKindType
	 */
	public RoleKindType getApplicableRoleKindTypeForAgmtKind(int kind) {

		AgreementKindType agmtType = AgreementKindType.getAgreementKindType(kind);

		switch (agmtType) {

		case BROKER:
	//	removing from autogen valiation - INC000005239870 - szp0603
	//	case BROKER_BRANCH_FRANCHISE:
	//	case BROKER_CONSULTANT: 
		case STOP_ORDER_BROKER:
			return RoleKindType.BELONGSTO;

		case FRANCHISE:
		case FRANCHISE_MANAGER:
			return RoleKindType.ISMANAGEDBY;

		case AGENT:
			return RoleKindType.REPORTSTO;

		default:
			return RoleKindType.BELONGSTO;

		}

	}
	
	/**
	 * Determine if party is an organisation or individual.  There is different logic for
	 * adding a new agreement and looking at an existing one
	 * 
	 * @param maintainPageModel
	 * @return
	 * @throws DataNotFoundException 
	 */
	public boolean isPartyOrganisation(MaintainAgreementDTO maintainAgreement) throws DataNotFoundException {
		
		return false;
		
		
	}
}
